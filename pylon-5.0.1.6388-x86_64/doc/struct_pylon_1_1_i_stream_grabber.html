<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-linux.css" rel="stylesheet" type="text/css"/>
<div><img src="Banner_PG.png" /></div>
</head>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_pylon.html">Pylon</a></li><li class="navelem"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html">IStreamGrabber</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interface_pylon_1_1_i_stream_grabber-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pylon::IStreamGrabber Interface Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___pylon___low_level_api.html">Low Level API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Low Level API: Interface to an (input) data stream.  
 <a href="struct_pylon_1_1_i_stream_grabber.html#details">More...</a></p>

<p><code>#include &lt;pylon/StreamGrabber.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a768babd8e14f19d48972054e02a97135"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a768babd8e14f19d48972054e02a97135"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a768babd8e14f19d48972054e02a97135">Open</a> (void)=0</td></tr>
<tr class="memdesc:a768babd8e14f19d48972054e02a97135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the stream grabber. <br/></td></tr>
<tr class="separator:a768babd8e14f19d48972054e02a97135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc837bce791a63f7dff74ed19afa7950"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#acc837bce791a63f7dff74ed19afa7950">Close</a> (void)=0</td></tr>
<tr class="memdesc:acc837bce791a63f7dff74ed19afa7950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream grabber.  <a href="#acc837bce791a63f7dff74ed19afa7950">More...</a><br/></td></tr>
<tr class="separator:acc837bce791a63f7dff74ed19afa7950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae923262bdb634c9d8593885781138a3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae923262bdb634c9d8593885781138a3e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#ae923262bdb634c9d8593885781138a3e">IsOpen</a> (void) const =0</td></tr>
<tr class="memdesc:ae923262bdb634c9d8593885781138a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve whether the stream grabber is open. <br/></td></tr>
<tr class="separator:ae923262bdb634c9d8593885781138a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727491835f24d67ff9e9e0bec46fd7be"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a727491835f24d67ff9e9e0bec46fd7be">RegisterBuffer</a> (void *Buffer, size_t BufferSize)=0</td></tr>
<tr class="memdesc:a727491835f24d67ff9e9e0bec46fd7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a buffer for subsequent use.  <a href="#a727491835f24d67ff9e9e0bec46fd7be">More...</a><br/></td></tr>
<tr class="separator:a727491835f24d67ff9e9e0bec46fd7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71821eec55efad0345024098d7ebdc30"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a71821eec55efad0345024098d7ebdc30">DeregisterBuffer</a> (<a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a>)=0</td></tr>
<tr class="memdesc:a71821eec55efad0345024098d7ebdc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregisters the buffer.  <a href="#a71821eec55efad0345024098d7ebdc30">More...</a><br/></td></tr>
<tr class="separator:a71821eec55efad0345024098d7ebdc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8452ec5676d92ea310bc6b5482e559"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a4d8452ec5676d92ea310bc6b5482e559">PrepareGrab</a> (void)=0</td></tr>
<tr class="memdesc:a4d8452ec5676d92ea310bc6b5482e559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares grabbing.  <a href="#a4d8452ec5676d92ea310bc6b5482e559">More...</a><br/></td></tr>
<tr class="separator:a4d8452ec5676d92ea310bc6b5482e559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0ed4cd4c209afccf4a46043de1e88a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a8e0ed4cd4c209afccf4a46043de1e88a">FinishGrab</a> (void)=0</td></tr>
<tr class="memdesc:a8e0ed4cd4c209afccf4a46043de1e88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops grabbing.  <a href="#a8e0ed4cd4c209afccf4a46043de1e88a">More...</a><br/></td></tr>
<tr class="separator:a8e0ed4cd4c209afccf4a46043de1e88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad12c655c9064a89c771d3c22a554bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#afad12c655c9064a89c771d3c22a554bb">QueueBuffer</a> (<a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a>, const void *Context=NULL)=0</td></tr>
<tr class="memdesc:afad12c655c9064a89c771d3c22a554bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a buffer in the input queue.  <a href="#afad12c655c9064a89c771d3c22a554bb">More...</a><br/></td></tr>
<tr class="separator:afad12c655c9064a89c771d3c22a554bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802212e61c56b1b824c4e5612656f056"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a802212e61c56b1b824c4e5612656f056">CancelGrab</a> (void)=0</td></tr>
<tr class="memdesc:a802212e61c56b1b824c4e5612656f056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels pending requests.  <a href="#a802212e61c56b1b824c4e5612656f056">More...</a><br/></td></tr>
<tr class="separator:a802212e61c56b1b824c4e5612656f056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbbda33475dec9e4482e7c8ff66c158"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aebbbda33475dec9e4482e7c8ff66c158">RetrieveResult</a> (<a class="el" href="class_pylon_1_1_grab_result.html">GrabResult</a> &amp;)=0</td></tr>
<tr class="memdesc:aebbbda33475dec9e4482e7c8ff66c158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a grab result from the output queue.  <a href="#aebbbda33475dec9e4482e7c8ff66c158">More...</a><br/></td></tr>
<tr class="separator:aebbbda33475dec9e4482e7c8ff66c158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f5d717ad59ae33467167202913dbf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#ab4f5d717ad59ae33467167202913dbf4">GetWaitObject</a> (void) const =0</td></tr>
<tr class="memdesc:ab4f5d717ad59ae33467167202913dbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result event object.  <a href="#ab4f5d717ad59ae33467167202913dbf4">More...</a><br/></td></tr>
<tr class="separator:ab4f5d717ad59ae33467167202913dbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c8096bd4a44c3df836b6c358748f20"><td class="memItemLeft" align="right" valign="top">virtual GenApi::INodeMap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a97c8096bd4a44c3df836b6c358748f20">GetNodeMap</a> (void)=0</td></tr>
<tr class="memdesc:a97c8096bd4a44c3df836b6c358748f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated stream grabber parameters.  <a href="#a97c8096bd4a44c3df836b6c358748f20">More...</a><br/></td></tr>
<tr class="separator:a97c8096bd4a44c3df836b6c358748f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low Level API: Interface to an (input) data stream. </p>
<p>Data is filled into user provided buffers. Before usage the buffers must be registered. After calling <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a4d8452ec5676d92ea310bc6b5482e559" title="Prepares grabbing. ">PrepareGrab()</a> enter them into a queue to become filled.</p>
<p>The streamgrabber provides a output queue which contains filled data buffers. While the queue is not empty the associated wait object is signaled. Get the buffer using the <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aebbbda33475dec9e4482e7c8ff66c158" title="Retrieves a grab result from the output queue. ">RetrieveResult()</a> method. When <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a8e0ed4cd4c209afccf4a46043de1e88a" title="Stops grabbing. ">FinishGrab()</a> is called the result queue remains open, so the data may be collected. It remains open until <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#acc837bce791a63f7dff74ed19afa7950" title="Closes the stream grabber. ">Close()</a> resp. the device is closed.</p>
<p>Parameter of streamgrabber are controlled by the elements of a own NodeMap, which can be retrieved by calling <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a97c8096bd4a44c3df836b6c358748f20" title="Returns the associated stream grabber parameters. ">GetNodeMap()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd>For an introduction into the usage of stream grabbers see <a class="el" href="low_level_api.html#grabbingimages">Grabbing Images</a> in the Programmer's Guide. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a802212e61c56b1b824c4e5612656f056"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::CancelGrab </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels pending requests. </p>
<p>, resources remain allocated. Following, the results must be retrieved from the Output Queue. </p>

</div>
</div>
<a class="anchor" id="acc837bce791a63f7dff74ed19afa7950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::Close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the stream grabber. </p>
<p>Flushes the result queue and stops the thread. </p>

</div>
</div>
<a class="anchor" id="a71821eec55efad0345024098d7ebdc30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* Pylon::IStreamGrabber::DeregisterBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deregisters the buffer. </p>
<p>Deregistering fails while the buffer is in use, so retrieve the buffer from the output queue after grabbing. </p>
<dl class="section note"><dt>Note</dt><dd>Do not delete buffers before they are deregistered. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e0ed4cd4c209afccf4a46043de1e88a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::FinishGrab </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops grabbing. </p>
<p>Releases the resources and camera. Pending grab requests are canceled. </p>

</div>
</div>
<a class="anchor" id="a97c8096bd4a44c3df836b6c358748f20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GenApi::INodeMap* Pylon::IStreamGrabber::GetNodeMap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the associated stream grabber parameters. </p>
<p>If no parameters are available, NULL is returned. </p>

</div>
</div>
<a class="anchor" id="ab4f5d717ad59ae33467167202913dbf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_wait_object.html">WaitObject</a>&amp; Pylon::IStreamGrabber::GetWaitObject </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result event object. </p>
<p>This object is associated with the result queue. The event is signaled when queue is non-empty </p>

</div>
</div>
<a class="anchor" id="a4d8452ec5676d92ea310bc6b5482e559"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::PrepareGrab </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares grabbing. </p>
<p>Allocates resources, synchronizes with the camera and locks critical parameter </p>

</div>
</div>
<a class="anchor" id="afad12c655c9064a89c771d3c22a554bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::IStreamGrabber::QueueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Context</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues a buffer in the input queue. </p>
<p>PrepareGrab is required to queue buffers. The context is returned together with the buffer and the grab result. It is not touched by the stream grabber. It is illegal to queue a buffer a second time before it is fetched from the result queue. </p>

</div>
</div>
<a class="anchor" id="a727491835f24d67ff9e9e0bec46fd7be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a> Pylon::IStreamGrabber::RegisterBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>BufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a buffer for subsequent use. </p>
<p>Stream must be locked to register buffers The Buffer size may not exceed the value specified when PrepareGrab was called. </p>

</div>
</div>
<a class="anchor" id="aebbbda33475dec9e4482e7c8ff66c158"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::IStreamGrabber::RetrieveResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_grab_result.html">GrabResult</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a grab result from the output queue. </p>
<dl class="section return"><dt>Returns</dt><dd>When result was available true is returned and and the first result is copied into the grabresult. Otherwise the grabresult remains unchanged and false is returned. </dd></dl>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>pylon/<a class="el" href="_stream_grabber_8h.html">StreamGrabber.h</a></li>
</ul>
</div><!-- contents -->
<hr><address><small>
&copy;&nbsp;2006-2015&nbsp;<a href="http://www.baslerweb.com/">Basler AG</a>   (Tue Dec 15 2015 14:56:56)</small></address>
</body>
</html>
