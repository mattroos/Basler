<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-linux.css" rel="stylesheet" type="text/css"/>
<div><img src="Banner_PG.png" /></div>
</head>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_pylon.html">Pylon</a></li><li class="navelem"><a class="el" href="class_pylon_1_1_c_image_format_converter.html">CImageFormatConverter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_pylon_1_1_c_image_format_converter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pylon::CImageFormatConverter Class Reference<div class="ingroups"><a class="el" href="group___pylon___image_handling_support.html">Image Handling Support</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Creates new images by converting a source image to another format.  
 <a href="class_pylon_1_1_c_image_format_converter.html#details">More...</a></p>

<p><code>#include &lt;pylon/ImageFormatConverter.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Pylon::CImageFormatConverter:</div>
<div class="dyncontent">
<div class="center"><img src="class_pylon_1_1_c_image_format_converter__inherit__graph.png" border="0" usemap="#_pylon_1_1_c_image_format_converter_inherit__map" alt="Inheritance graph"/></div>
<map name="_pylon_1_1_c_image_format_converter_inherit__map" id="_pylon_1_1_c_image_format_converter_inherit__map">
<area shape="rect" id="node2" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html" title="Interface to image format converter parameters. " alt="" coords="5,5,269,61"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2669ed52fd7aa6534007ce88359d0100"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a2669ed52fd7aa6534007ce88359d0100">CImageFormatConverter</a> ()</td></tr>
<tr class="memdesc:a2669ed52fd7aa6534007ce88359d0100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an image format converter.  <a href="#a2669ed52fd7aa6534007ce88359d0100">More...</a><br/></td></tr>
<tr class="separator:a2669ed52fd7aa6534007ce88359d0100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c519c818458fc595198321e1218bd25"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a8c519c818458fc595198321e1218bd25">~CImageFormatConverter</a> ()</td></tr>
<tr class="memdesc:a8c519c818458fc595198321e1218bd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the image format converter.  <a href="#a8c519c818458fc595198321e1218bd25">More...</a><br/></td></tr>
<tr class="separator:a8c519c818458fc595198321e1218bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e0bfa31faa1734059de39b37861aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a2e2e0bfa31faa1734059de39b37861aa">Initialize</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> sourcePixelType)</td></tr>
<tr class="memdesc:a2e2e0bfa31faa1734059de39b37861aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally initializes the image format converter before conversion.  <a href="#a2e2e0bfa31faa1734059de39b37861aa">More...</a><br/></td></tr>
<tr class="separator:a2e2e0bfa31faa1734059de39b37861aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab360f8e35a623b960b2ad036973bd646"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#ab360f8e35a623b960b2ad036973bd646">IsInitialized</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> sourcePixelType) const </td></tr>
<tr class="memdesc:ab360f8e35a623b960b2ad036973bd646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the converter being initialized.  <a href="#ab360f8e35a623b960b2ad036973bd646">More...</a><br/></td></tr>
<tr class="separator:ab360f8e35a623b960b2ad036973bd646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43410910821c29054d8dd7b3b2090895"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a43410910821c29054d8dd7b3b2090895">Uninitialize</a> ()</td></tr>
<tr class="memdesc:a43410910821c29054d8dd7b3b2090895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys data structures required for conversion.  <a href="#a43410910821c29054d8dd7b3b2090895">More...</a><br/></td></tr>
<tr class="separator:a43410910821c29054d8dd7b3b2090895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48e971b1d2cc8d88efa1480c2cae578"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#ae48e971b1d2cc8d88efa1480c2cae578">ImageHasDestinationFormat</a> (const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;sourceImage) const </td></tr>
<tr class="memdesc:ae48e971b1d2cc8d88efa1480c2cae578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a conversion is required or if the source image already has the desired format.  <a href="#ae48e971b1d2cc8d88efa1480c2cae578">More...</a><br/></td></tr>
<tr class="separator:ae48e971b1d2cc8d88efa1480c2cae578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53845358352ba5aa1127e40d8af63b4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#aa53845358352ba5aa1127e40d8af63b4">ImageHasDestinationFormat</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> sourcePixelType, size_t sourcePaddingX, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> sourceOrientation) const </td></tr>
<tr class="memdesc:aa53845358352ba5aa1127e40d8af63b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a conversion is required or if the source image already has the desired format.  <a href="#aa53845358352ba5aa1127e40d8af63b4">More...</a><br/></td></tr>
<tr class="separator:aa53845358352ba5aa1127e40d8af63b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae221c6d1f59177ba56d494ec53193407"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#ae221c6d1f59177ba56d494ec53193407">GetBufferSizeForConversion</a> (const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;sourceImage) const </td></tr>
<tr class="memdesc:ae221c6d1f59177ba56d494ec53193407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the size of the destination image buffer in byte.  <a href="#ae221c6d1f59177ba56d494ec53193407">More...</a><br/></td></tr>
<tr class="separator:ae221c6d1f59177ba56d494ec53193407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74205feafaf44e5872f855c2f04c8d61"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a74205feafaf44e5872f855c2f04c8d61">GetBufferSizeForConversion</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> sourcePixelType, uint32_t sourceWidth, uint32_t sourceHeight) const </td></tr>
<tr class="memdesc:a74205feafaf44e5872f855c2f04c8d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the size of the destination image buffer in byte.  <a href="#a74205feafaf44e5872f855c2f04c8d61">More...</a><br/></td></tr>
<tr class="separator:a74205feafaf44e5872f855c2f04c8d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4690d0b5b50581d229bd00794430b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a1d4690d0b5b50581d229bd00794430b7">Convert</a> (<a class="el" href="struct_pylon_1_1_i_reusable_image.html">IReusableImage</a> &amp;destinationImage, const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;sourceImage)</td></tr>
<tr class="memdesc:a1d4690d0b5b50581d229bd00794430b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new image by converting an image to a different format.  <a href="#a1d4690d0b5b50581d229bd00794430b7">More...</a><br/></td></tr>
<tr class="separator:a1d4690d0b5b50581d229bd00794430b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b6fbf102fb6836274a4762b86cc243"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#ab5b6fbf102fb6836274a4762b86cc243">Convert</a> (<a class="el" href="struct_pylon_1_1_i_reusable_image.html">IReusableImage</a> &amp;destinationImage, const void *pSourceBuffer, size_t sourceBufferSizeBytes, <a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> sourcePixelType, uint32_t sourceWidth, uint32_t sourceHeight, size_t sourcePaddingX, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> sourceOrientation)</td></tr>
<tr class="memdesc:ab5b6fbf102fb6836274a4762b86cc243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new image by converting an image to a different format.  <a href="#ab5b6fbf102fb6836274a4762b86cc243">More...</a><br/></td></tr>
<tr class="separator:ab5b6fbf102fb6836274a4762b86cc243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeac3e7b6ef31b65ab1906c066add98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#acbeac3e7b6ef31b65ab1906c066add98">Convert</a> (void *pDestinationBuffer, size_t destinationBufferSizeBytes, const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;sourceImage)</td></tr>
<tr class="memdesc:acbeac3e7b6ef31b65ab1906c066add98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new image by converting an image to a different format.  <a href="#acbeac3e7b6ef31b65ab1906c066add98">More...</a><br/></td></tr>
<tr class="separator:acbeac3e7b6ef31b65ab1906c066add98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99f8a9681090b7c03410d6afed7bf9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#af99f8a9681090b7c03410d6afed7bf9f">Convert</a> (void *pDestinationBuffer, size_t destinationBufferSizeBytes, const void *pSourceBuffer, size_t sourceBufferSizeBytes, <a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> sourcePixelType, uint32_t sourceWidth, uint32_t sourceHeight, size_t sourcePaddingX, <a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a> sourceOrientation)</td></tr>
<tr class="memdesc:af99f8a9681090b7c03410d6afed7bf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new image by converting an image to a different format.  <a href="#af99f8a9681090b7c03410d6afed7bf9f">More...</a><br/></td></tr>
<tr class="separator:af99f8a9681090b7c03410d6afed7bf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b2bec7fb5867f833b91774b55b7a13"><td class="memItemLeft" align="right" valign="top">virtual GenApi::INodeMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a78b2bec7fb5867f833b91774b55b7a13">GetNodeMap</a> ()</td></tr>
<tr class="memdesc:a78b2bec7fb5867f833b91774b55b7a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the node map of the format converter.  <a href="#a78b2bec7fb5867f833b91774b55b7a13">More...</a><br/></td></tr>
<tr class="separator:a78b2bec7fb5867f833b91774b55b7a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad2e93a41bac60caf3456173f89201b8c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#ad2e93a41bac60caf3456173f89201b8c">IsSupportedInputFormat</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> sourcePixelType)</td></tr>
<tr class="memdesc:ad2e93a41bac60caf3456173f89201b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the image format defined by the given pixel type is a supported input format.  <a href="#ad2e93a41bac60caf3456173f89201b8c">More...</a><br/></td></tr>
<tr class="separator:ad2e93a41bac60caf3456173f89201b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002e48b1e4b5512a872b1dad96fd39ba"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a002e48b1e4b5512a872b1dad96fd39ba">IsSupportedOutputFormat</a> (<a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a> destinationPixelType)</td></tr>
<tr class="memdesc:a002e48b1e4b5512a872b1dad96fd39ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the image format defined by the given pixel type is a supported output format.  <a href="#a002e48b1e4b5512a872b1dad96fd39ba">More...</a><br/></td></tr>
<tr class="separator:a002e48b1e4b5512a872b1dad96fd39ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3e2947f7f3b7d20c5fb351e2a3953f5a"><td class="memItemLeft" align="right" valign="top">IOutputPixelFormatEnum &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_c_image_format_converter.html#a3e2947f7f3b7d20c5fb351e2a3953f5a">OutputPixelFormat</a></td></tr>
<tr class="memdesc:a3e2947f7f3b7d20c5fb351e2a3953f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pixel data format of the output image.  <a href="#a3e2947f7f3b7d20c5fb351e2a3953f5a">More...</a><br/></td></tr>
<tr class="separator:a3e2947f7f3b7d20c5fb351e2a3953f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Root - Image Format Converter parameters.</div></td></tr>
<tr class="memitem:a8726267b699b4b40c2faf32c482ad5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_gen_api_1_1_i_enumeration_t.html">GenApi::IEnumerationT</a><br class="typebreak"/>
&lt; <a class="el" href="namespace_basler___image_format_converter_params.html#a0d468bef66c1b6903dece1bcb2ab4016">OutputBitAlignmentEnums</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html#a8726267b699b4b40c2faf32c482ad5aa">OutputBitAlignment</a></td></tr>
<tr class="memdesc:a8726267b699b4b40c2faf32c482ad5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the alignment of the bits in the target pixel type.  <a href="#a8726267b699b4b40c2faf32c482ad5aa">More...</a><br/></td></tr>
<tr class="separator:a8726267b699b4b40c2faf32c482ad5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd76d0db17afbc32d301db0f47d46211"><td class="memItemLeft" align="right" valign="top">GenApi::IInteger &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html#acd76d0db17afbc32d301db0f47d46211">OutputPaddingX</a></td></tr>
<tr class="memdesc:acd76d0db17afbc32d301db0f47d46211"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of additional data bytes at the end of each line.  <a href="#acd76d0db17afbc32d301db0f47d46211">More...</a><br/></td></tr>
<tr class="separator:acd76d0db17afbc32d301db0f47d46211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdcef2cfc75356772d97fac29dff28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_gen_api_1_1_i_enumeration_t.html">GenApi::IEnumerationT</a><br class="typebreak"/>
&lt; <a class="el" href="namespace_basler___image_format_converter_params.html#a2b8f33b49173d7c4f6fa617da09593b1">OutputOrientationEnums</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html#a4fdcef2cfc75356772d97fac29dff28a">OutputOrientation</a></td></tr>
<tr class="memdesc:a4fdcef2cfc75356772d97fac29dff28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the vertical orientation of the output image in memory.  <a href="#a4fdcef2cfc75356772d97fac29dff28a">More...</a><br/></td></tr>
<tr class="separator:a4fdcef2cfc75356772d97fac29dff28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea93e41ee1812d701ab539dd4c55419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_gen_api_1_1_i_enumeration_t.html">GenApi::IEnumerationT</a><br class="typebreak"/>
&lt; <a class="el" href="namespace_basler___image_format_converter_params.html#ac0c310611b5549a59f93f78a3415ce67">InconvertibleEdgeHandlingEnums</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html#aaea93e41ee1812d701ab539dd4c55419">InconvertibleEdgeHandling</a></td></tr>
<tr class="memdesc:aaea93e41ee1812d701ab539dd4c55419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the handling for rows and columns that cannot be converted.  <a href="#aaea93e41ee1812d701ab539dd4c55419">More...</a><br/></td></tr>
<tr class="separator:aaea93e41ee1812d701ab539dd4c55419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">MonoConversion - Parameters for converting monochrome images.</div></td></tr>
<tr class="memitem:a87606c1e97872b53025dea6b34344d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_gen_api_1_1_i_enumeration_t.html">GenApi::IEnumerationT</a><br class="typebreak"/>
&lt; <a class="el" href="namespace_basler___image_format_converter_params.html#adc7787bb78358a37c064d521331d4269">MonoConversionMethodEnums</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html#a87606c1e97872b53025dea6b34344d52">MonoConversionMethod</a></td></tr>
<tr class="memdesc:a87606c1e97872b53025dea6b34344d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the conversion method for monochrome images.  <a href="#a87606c1e97872b53025dea6b34344d52">More...</a><br/></td></tr>
<tr class="separator:a87606c1e97872b53025dea6b34344d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0aebd7b567a1aa08c0cc8a1c0e4ba99"><td class="memItemLeft" align="right" valign="top">GenApi::IFloat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html#af0aebd7b567a1aa08c0cc8a1c0e4ba99">Gamma</a></td></tr>
<tr class="memdesc:af0aebd7b567a1aa08c0cc8a1c0e4ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gamma value for converting monochrome images.  <a href="#af0aebd7b567a1aa08c0cc8a1c0e4ba99">More...</a><br/></td></tr>
<tr class="separator:af0aebd7b567a1aa08c0cc8a1c0e4ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe93fef92f4e0491550c2cf6f72dfd5"><td class="memItemLeft" align="right" valign="top">GenApi::IInteger &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html#aafe93fef92f4e0491550c2cf6f72dfd5">AdditionalLeftShift</a></td></tr>
<tr class="memdesc:aafe93fef92f4e0491550c2cf6f72dfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value for additional shifting when converting monochrome images in Truncate mode.  <a href="#aafe93fef92f4e0491550c2cf6f72dfd5">More...</a><br/></td></tr>
<tr class="separator:aafe93fef92f4e0491550c2cf6f72dfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Creates new images by converting a source image to another format. </p>
<p>Supported input image formats defined by the pixel type: </p>
<pre class="fragment">&lt;ul&gt;
&lt;li&gt; PixelType_Mono1packed
&lt;li&gt; PixelType_Mono2packed
&lt;li&gt; PixelType_Mono4packed
&lt;li&gt; PixelType_Mono8
&lt;li&gt; PixelType_Mono10
&lt;li&gt; PixelType_Mono10packed
&lt;li&gt; PixelType_Mono10p
&lt;li&gt; PixelType_Mono12
&lt;li&gt; PixelType_Mono12packed
&lt;li&gt; PixelType_Mono12p
&lt;li&gt; PixelType_Mono16
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt; PixelType_BayerGR8
&lt;li&gt; PixelType_BayerRG8
&lt;li&gt; PixelType_BayerGB8
&lt;li&gt; PixelType_BayerBG8
&lt;li&gt; PixelType_BayerGR10
&lt;li&gt; PixelType_BayerRG10
&lt;li&gt; PixelType_BayerGB10
&lt;li&gt; PixelType_BayerBG10
&lt;li&gt; PixelType_BayerGR12
&lt;li&gt; PixelType_BayerRG12
&lt;li&gt; PixelType_BayerGB12
&lt;li&gt; PixelType_BayerBG12
&lt;li&gt; PixelType_BayerGR12Packed
&lt;li&gt; PixelType_BayerRG12Packed
&lt;li&gt; PixelType_BayerGB12Packed
&lt;li&gt; PixelType_BayerBG12Packed
&lt;li&gt; PixelType_BayerGR10p
&lt;li&gt; PixelType_BayerRG10p
&lt;li&gt; PixelType_BayerGB10p
&lt;li&gt; PixelType_BayerBG10p
&lt;li&gt; PixelType_BayerGR12p
&lt;li&gt; PixelType_BayerRG12p
&lt;li&gt; PixelType_BayerGB12p
&lt;li&gt; PixelType_BayerBG12p
&lt;li&gt; PixelType_BayerGR16
&lt;li&gt; PixelType_BayerRG16
&lt;li&gt; PixelType_BayerGB16
&lt;li&gt; PixelType_BayerBG16
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt; PixelType_RGB8packed
&lt;li&gt; PixelType_BGR8packed
&lt;li&gt; PixelType_RGBA8packed
&lt;li&gt; PixelType_BGRA8packed
&lt;li&gt; PixelType_RGB10packed
&lt;li&gt; PixelType_BGR10packed
&lt;li&gt; PixelType_RGB12packed
&lt;li&gt; PixelType_BGR12packed
&lt;li&gt; PixelType_RGB12V1packed
&lt;li&gt; PixelType_RGB16packed
&lt;li&gt; PixelType_RGB8planar
&lt;li&gt; PixelType_RGB16planar
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt; PixelType_YUV422packed
&lt;li&gt; PixelType_YUV422_YUYV_Packed
&lt;/ul&gt;
</pre><p>Supported ouput image formats defined by the pixel type: </p>
<pre class="fragment">&lt;ul&gt;
&lt;li&gt; PixelType_BGRA8packed - This pixel type can be used in Windows bitmaps. See Pylon::SBGRA8Pixel.
&lt;li&gt; PixelType_BGR8packed - This pixel type can be used in Windows bitmaps. See Pylon::SBGR8Pixel.
&lt;li&gt; PixelType_RGB8packed - See Pylon::SRGB8Pixel.
&lt;li&gt; PixelType_RGB16packed - See Pylon::SRGB16Pixel.
&lt;li&gt; PixelType_RGB8planar
&lt;li&gt; PixelType_RGB16planar
&lt;li&gt; PixelType_Mono8
&lt;li&gt; PixelType_Mono16
&lt;/ul&gt;
</pre><p>All input image formats can be converted to all output image formats.</p>
<p>RGB, BGR and Bayer image formats are converted to monochrome formats by using the following formula:</p>
<div class="fragment"><div class="line">mono = (0.25 * red) + (0.625 * green) + (0.125 * blue);</div>
</div><!-- fragment --><p>YUV formats are converted to 16 bit bit depth in an intermediate conversion step. This is why the output is always aligned at the most significant bit when converting to 16 bit color output formats like PixelType_RGB16packed.</p>
<dl class="section user"><dt>Limitations:</dt><dd>The last column of a YUV input image with odd width cannot be converted. The last column and the last row of a Bayer input image cannot be converted.</dd></dl>
<p>The default treatment of rows and columns that cannot be converted due to their location on edges, can be controlled using the <a class="el" href="class_basler___image_format_converter_params_1_1_c_image_format_converter_params___params.html#aaea93e41ee1812d701ab539dd4c55419" title="Sets the handling for rows and columns that cannot be converted. ">CImageFormatConverter::InconvertibleEdgeHandling</a> parameter. See also the <a class="el" href="class_pylon_1_1_c_image_format_converter.html#a1d4690d0b5b50581d229bd00794430b7" title="Creates a new image by converting an image to a different format. ">Convert()</a> method description.</p>
<dl class="section user"><dt>Thread Safety:</dt><dd>The <a class="el" href="class_pylon_1_1_c_image_format_converter.html" title="Creates new images by converting a source image to another format. ">CImageFormatConverter</a> class is not thread-safe. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2669ed52fd7aa6534007ce88359d0100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pylon::CImageFormatConverter::CImageFormatConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an image format converter. </p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c519c818458fc595198321e1218bd25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Pylon::CImageFormatConverter::~CImageFormatConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the image format converter. </p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1d4690d0b5b50581d229bd00794430b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CImageFormatConverter::Convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pylon_1_1_i_reusable_image.html">IReusableImage</a> &amp;&#160;</td>
          <td class="paramname"><em>destinationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new image by converting an image to a different format. </p>
<p>The <a class="el" href="struct_pylon_1_1_i_reusable_image.html#a2c7c0b9af92bf529e352e745b91ba2da" title="Resets the image properties and provides a buffer to hold the image. ">IReusableImage::Reset()</a> method of the destination image is called to set the destination format. The image is converted to the destination image according to the current converter settings. The padding area of a row in the destination image is set to zero.</p>
<p>The OutputPaddingX setting is ignored for images that do not support user defined padding, e.g. CPylonBitmapImage. See also <a class="el" href="struct_pylon_1_1_i_reusable_image.html#ab168b1c119ddc278b2a4a37e63fc29bf" title="Can be used to check whether the value of PaddingX can be defined by the user. ">IReusableImage::IsAdditionalPaddingSupported()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destinationImage</td><td>The destination image, e.g. a <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a> or CPylonBitmapImage object. When passing a CPylonBitmapImage object the target format must be supported by the CPylonBitmapImage class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceImage</td><td>The source image, e.g. a <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a>, CPylonBitmapImage, or Grab Result Smart Pointer object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The source and destination images must be different images. </li>
<li>
The source image must be valid. </li>
<li>
The format of the source image must be supported by the converter. </li>
<li>
The destination image must support the destination format. </li>
<li>
The destination image must be able to provide a large enough buffer to hold the image. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the passed parameters are not valid. The converter object is still valid after error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5b6fbf102fb6836274a4762b86cc243"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CImageFormatConverter::Convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pylon_1_1_i_reusable_image.html">IReusableImage</a> &amp;&#160;</td>
          <td class="paramname"><em>destinationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sourceBufferSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>sourcePixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sourceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sourceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sourcePaddingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>sourceOrientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new image by converting an image to a different format. </p>
<p>The <a class="el" href="struct_pylon_1_1_i_reusable_image.html#a2c7c0b9af92bf529e352e745b91ba2da" title="Resets the image properties and provides a buffer to hold the image. ">IReusableImage::Reset()</a> method of the destination image is called to set the destination format. The image is converted to the destination image according to the current converter settings. The padding area of a row in the destination image is set to zero.</p>
<p>The OutputPaddingX setting is ignored for images that do not support user defined padding, e.g. CPylonBitmapImage. See also <a class="el" href="struct_pylon_1_1_i_reusable_image.html#ab168b1c119ddc278b2a4a37e63fc29bf" title="Can be used to check whether the value of PaddingX can be defined by the user. ">IReusableImage::IsAdditionalPaddingSupported()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destinationImage</td><td>The destination image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSourceBuffer</td><td>The pointer to the buffer of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceBufferSizeBytes</td><td>The size of the buffer of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePixelType</td><td>The pixel type of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceWidth</td><td>The number of pixels in a row in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceHeight</td><td>The number of rows in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePaddingX</td><td>The number of extra data bytes at the end of each row. The default value is usually 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceOrientation</td><td>The vertical orientation of the source image in the image buffer. The default value is usually ImageOrientation_TopDown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The pixel type must be valid. </li>
<li>
The <code>sourceWidth</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The <code>sourceHeight</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The pointer to the source buffer must not be NULL. </li>
<li>
The source buffer must be large enough to hold the image described by the parameters. </li>
<li>
The format of the input image represented by the given parameter must be supported by the converter. </li>
<li>
The destination image must support the destination format. </li>
<li>
The destination image must be able to provide a large enough buffer to hold the image. </li>
<li>
The source image buffer and the destination image buffer must not be identical. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the passed parameters are not valid. The converter object is still valid after error. </dd></dl>

</div>
</div>
<a class="anchor" id="acbeac3e7b6ef31b65ab1906c066add98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CImageFormatConverter::Convert </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDestinationBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destinationBufferSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new image by converting an image to a different format. </p>
<p>The image is converted to the destination image according to the current converter settings. The padding area of a row in the destination image is set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDestinationBuffer</td><td>The pointer to the buffer of the destination image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationBufferSizeBytes</td><td>The size of the buffer of the destination image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceImage</td><td>The source image, e.g. a <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a>, CPylonBitmapImage, or Grab Result Smart Pointer object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The format of the source image must be supported by the converter. </li>
<li>
The destination image buffer must be large enough to hold the destination image. </li>
<li>
The source image buffer and the destination image buffer must not be identical. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the passed parameters are not valid. The converter object is still valid after error. </dd></dl>

</div>
</div>
<a class="anchor" id="af99f8a9681090b7c03410d6afed7bf9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CImageFormatConverter::Convert </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDestinationBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destinationBufferSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sourceBufferSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>sourcePixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sourceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sourceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sourcePaddingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>sourceOrientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new image by converting an image to a different format. </p>
<p>The image is converted to the destination image according to the current converter settings. The padding area of a row in the destination image is set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pDestinationBuffer</td><td>The pointer to the buffer of the destination image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationBufferSizeBytes</td><td>The size of the buffer of the destination image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSourceBuffer</td><td>The pointer to the buffer of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceBufferSizeBytes</td><td>The size of the buffer of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePixelType</td><td>The pixel type of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceWidth</td><td>The number of pixels in a row in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceHeight</td><td>The number of rows in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePaddingX</td><td>The number of extra data bytes at the end of each row. The default value is usually 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceOrientation</td><td>The vertical orientation of the source image in the image buffer. The default value is usually ImageOrientation_TopDown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The parameters regarding the source buffer must describe a valid image. </li>
<li>
The format of the input image represented by the given parameter must be supported by the converter. </li>
<li>
If the destination image buffer must be large enough to hold the destination image. </li>
<li>
The the source buffer can not be equal the destination buffer. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the passed parameters are not valid. The converter object is still valid after error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae221c6d1f59177ba56d494ec53193407"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Pylon::CImageFormatConverter::GetBufferSizeForConversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceImage</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the size of the destination image buffer in byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceImage</td><td>The source image, e.g. a <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a>, CPylonBitmapImage, or Grab Result Smart Pointer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the destination image when converting the given source image using current converter settings.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the destination image size for the passed input cannot be computed. The converter object is still valid after error. </dd></dl>

</div>
</div>
<a class="anchor" id="a74205feafaf44e5872f855c2f04c8d61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Pylon::CImageFormatConverter::GetBufferSizeForConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>sourcePixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sourceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sourceHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the size of the destination image buffer in byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceWidth</td><td>The number of pixels in a row in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceHeight</td><td>The number of rows in the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePixelType</td><td>The pixel type of the source image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the destination image when converting the source image using current converter settings.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The <code>sourceWidth</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
<li>
The <code>sourceHeight</code> value must be &gt;= 0 and &lt; _I32_MAX. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the destination image size for the passed input cannot be computed. The converter object is still valid after error. </dd></dl>

</div>
</div>
<a class="anchor" id="a78b2bec7fb5867f833b91774b55b7a13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GenApi::INodeMap&amp; Pylon::CImageFormatConverter::GetNodeMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the node map of the format converter. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the node map of the format converter.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="ae48e971b1d2cc8d88efa1480c2cae578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CImageFormatConverter::ImageHasDestinationFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_pylon_1_1_i_image.html">IImage</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceImage</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if a conversion is required or if the source image already has the desired format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceImage</td><td>The source image, e.g. a <a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">CPylonImage</a>, CPylonBitmapImage, or Grab Result Smart Pointer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the source image already has the desired format.</dd></dl>
<p>A conversion may even be required image format does not change e.g. if the gamma conversion method is selected and the format describes a monochrome image.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="aa53845358352ba5aa1127e40d8af63b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CImageFormatConverter::ImageHasDestinationFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>sourcePixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sourcePaddingX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga710fdd7cf7f7516c56b90cbdf0085f70">EImageOrientation</a>&#160;</td>
          <td class="paramname"><em>sourceOrientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if a conversion is required or if the source image already has the desired format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePixelType</td><td>The pixel type of the source image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePaddingX</td><td>The number of extra data bytes at the end of each row. The default value is usually 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceOrientation</td><td>The vertical orientation of the image in the image buffer. The default value is usually ImageOrientation_TopDown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the source image already has the desired format. This is done according to the current converter settings.</dd></dl>
<p>A conversion may even be required image format does not change e.g. if the gamma conversion method is selected and the format describes a monochrome image.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e2e0bfa31faa1734059de39b37861aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CImageFormatConverter::Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>sourcePixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optionally initializes the image format converter before conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePixelType</td><td>The pixel type of the source image.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>
Depending on parameter settings and the input format, data structures required for conversion are created, e.g. lookup tables. </li>
<li>
Initialization is done automatically when calling <a class="el" href="class_pylon_1_1_c_image_format_converter.html#a1d4690d0b5b50581d229bd00794430b7" title="Creates a new image by converting an image to a different format. ">Convert()</a> if needed. This may add a delay when converting the first image. </li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The converter parameters are set up. </li>
<li>
The <code>pixelTypeSource</code> must be supported by the converter. </li>
</ul>
</dd></dl>
<p>Lookup tables are created when using monochrome images as input and when the gamma conversion method is selected or when the shift conversion method is selected and the value of AdditionalLeftShift is not zero. The converter can be reinitialized with other settings if required.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the passed pixel type does not represent a valid input format. The converter object is still valid after error and can be initialized again. </dd></dl>

</div>
</div>
<a class="anchor" id="ab360f8e35a623b960b2ad036973bd646"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::CImageFormatConverter::IsInitialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>sourcePixelType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about the converter being initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePixelType</td><td>The pixel type of the source image.</td></tr>
  </table>
  </dd>
</dl>
<p>The result depends on the converter settings.</p>
<dl class="section return"><dt>Returns</dt><dd>True if initialized.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2e93a41bac60caf3456173f89201b8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pylon::CImageFormatConverter::IsSupportedInputFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>sourcePixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the image format defined by the given pixel type is a supported input format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourcePixelType</td><td>The pixel type of the source image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a002e48b1e4b5512a872b1dad96fd39ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pylon::CImageFormatConverter::IsSupportedOutputFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___pylon___image_handling_support.html#ga159b4bb49b4973a30bc8b39a4fcf3067">EPixelType</a>&#160;</td>
          <td class="paramname"><em>destinationPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the image format defined by the given pixel type is a supported output format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destinationPixelType</td><td>The pixel type of the destination image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a43410910821c29054d8dd7b3b2090895"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::CImageFormatConverter::Uninitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys data structures required for conversion. </p>
<p>This function can be called to free resources held by the format converter.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Does not throw C++ exceptions. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aafe93fef92f4e0491550c2cf6f72dfd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GenApi::IInteger&amp; Basler_ImageFormatConverterParams::CImageFormatConverterParams_Params::AdditionalLeftShift</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value for additional shifting when converting monochrome images in Truncate mode. </p>
<p>Sets the value for additional shifting when converting monochrome images in Truncate mode. The image data is converted using a lookup table if the parameter value differs from zero. Shifted values exceeding the maximum output value boundary are set to the maximum allowed value. Negative values are treated as right shifted values.</p>
<p><b>Visibility</b> = Beginner </p>

</div>
</div>
<a class="anchor" id="af0aebd7b567a1aa08c0cc8a1c0e4ba99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GenApi::IFloat&amp; Basler_ImageFormatConverterParams::CImageFormatConverterParams_Params::Gamma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gamma value for converting monochrome images. </p>
<p>Sets the gamma value for converting monochrome images. The image data is converted using a lookup table. The values of the lookup table are computed using the following formula: valueOut = min((((valueIn ^ Gamma) / (valueInMax ^ Gamma)) * valueOutMax), valueOutMax).</p>
<p><b>Visibility</b> = Beginner </p>

</div>
</div>
<a class="anchor" id="aaea93e41ee1812d701ab539dd4c55419"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_gen_api_1_1_i_enumeration_t.html">GenApi::IEnumerationT</a>&lt;<a class="el" href="namespace_basler___image_format_converter_params.html#ac0c310611b5549a59f93f78a3415ce67">InconvertibleEdgeHandlingEnums</a> &gt;&amp; Basler_ImageFormatConverterParams::CImageFormatConverterParams_Params::InconvertibleEdgeHandling</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the handling for rows and columns that cannot be converted. </p>
<p>Sets the handling for rows and columns that cannot be converted.</p>
<p><b>Visibility</b> = Beginner </p>

</div>
</div>
<a class="anchor" id="a87606c1e97872b53025dea6b34344d52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_gen_api_1_1_i_enumeration_t.html">GenApi::IEnumerationT</a>&lt;<a class="el" href="namespace_basler___image_format_converter_params.html#adc7787bb78358a37c064d521331d4269">MonoConversionMethodEnums</a> &gt;&amp; Basler_ImageFormatConverterParams::CImageFormatConverterParams_Params::MonoConversionMethod</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the conversion method for monochrome images. </p>
<p>Sets the conversion method for monochrome images.</p>
<p><b>Visibility</b> = Beginner </p>

</div>
</div>
<a class="anchor" id="a8726267b699b4b40c2faf32c482ad5aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_gen_api_1_1_i_enumeration_t.html">GenApi::IEnumerationT</a>&lt;<a class="el" href="namespace_basler___image_format_converter_params.html#a0d468bef66c1b6903dece1bcb2ab4016">OutputBitAlignmentEnums</a> &gt;&amp; Basler_ImageFormatConverterParams::CImageFormatConverterParams_Params::OutputBitAlignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls the alignment of the bits in the target pixel type. </p>
<p>Controls the alignment of the bits in the target pixel type if the target value has more bits than the source value.</p>
<p><b>Visibility</b> = Beginner </p>

</div>
</div>
<a class="anchor" id="a4fdcef2cfc75356772d97fac29dff28a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_gen_api_1_1_i_enumeration_t.html">GenApi::IEnumerationT</a>&lt;<a class="el" href="namespace_basler___image_format_converter_params.html#a2b8f33b49173d7c4f6fa617da09593b1">OutputOrientationEnums</a> &gt;&amp; Basler_ImageFormatConverterParams::CImageFormatConverterParams_Params::OutputOrientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the vertical orientation of the output image in memory. </p>
<p>Defines the vertical orientation of the output image in memory.</p>
<p><b>Visibility</b> = Beginner </p>

</div>
</div>
<a class="anchor" id="acd76d0db17afbc32d301db0f47d46211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GenApi::IInteger&amp; Basler_ImageFormatConverterParams::CImageFormatConverterParams_Params::OutputPaddingX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of additional data bytes at the end of each line. </p>
<p>The number of additional data bytes at the end of each line. These bytes are set to zero during the conversion.</p>
<p><b>Visibility</b> = Beginner </p>

</div>
</div>
<a class="anchor" id="a3e2947f7f3b7d20c5fb351e2a3953f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IOutputPixelFormatEnum&amp; Pylon::CImageFormatConverter::OutputPixelFormat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pixel data format of the output image. </p>
<p>This member can be used to get and set the output pixel format using the EPixelType enumeration. It emulates the behavior of native parameter access.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The pixel format set must be a supported output pixel format. See <a class="el" href="class_pylon_1_1_c_image_format_converter.html#a002e48b1e4b5512a872b1dad96fd39ba" title="Returns true if the image format defined by the given pixel type is a supported output format...">IsSupportedOutputFormat()</a>. </dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the set output pixel format is not supported. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pylon/<a class="el" href="_image_format_converter_8h.html">ImageFormatConverter.h</a></li>
</ul>
</div><!-- contents -->
<hr><address><small>
&copy;&nbsp;2006-2015&nbsp;<a href="http://www.baslerweb.com/">Basler AG</a>   (Tue Dec 15 2015 14:56:56)</small></address>
</body>
</html>
