<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-linux.css" rel="stylesheet" type="text/css"/>
<div><img src="Banner_PG.png" /></div>
</head>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Programmer's Guide and API Reference for pylon for Linux</a></li><li class="navelem"><a class="el" href="pylon_advanced_topics.html">Advanced Topics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Programming Using the Low Level API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="low_level_api.html#LowLevelCameraObjects_Low">Low Level Camera Classes</a> </li>
<li><a class="el" href="low_level_api.html#grabbingimages">Grabbing Images</a> </li>
<li><a class="el" href="low_level_api.html#grabbingevents">Handling Camera Events</a> </li>
<li><a class="el" href="low_level_api.html#parsingchunks">Chunk Parser: Accessing Chunk Features</a> </li>
<li><a class="el" href="low_level_api.html#pnp">Getting Informed About Device Removal</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The Low Level API should only be used for existing applications and for rare highly advanced use cases that cannot be covered using the Instant Camera classes. Please use the Instant Camera classes whenever possible instead of the Low Level API.</dd></dl>
<h1><a class="anchor" id="LowLevelCameraObjects_Low"></a>
Low Level Camera Classes</h1>
<p>A Low Level API camera object wraps a <a class="el" href="struct_pylon_1_1_i_pylon_device.html">pylon Device</a> providing more convenient access to the parameters of the Camera, the Stream Grabber, the Event Grabber, and the Transport Layer using GenApi parameter classes.</p>
<p>The following table shows the currently available classes: </p>
<table  border="1" class="table" frame="void" cellspacing="6" cellpadding="7">
<tr>
<th>Transport Layer </th><th>Name of Class </th><th><p class="starttd">Kind of Devices </p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>Pylon1394 </td><td><code>Pylon::CBasler1394Camera</code>  </td><td><p class="starttd">IIDC 1394 compliant cameras </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>PylonGigE </td><td><code><a class="el" href="class_pylon_1_1_c_basler_gig_e_camera.html" title="Low Level API: The camera class for Basler GigE Vision camera devices. ">Pylon::CBaslerGigECamera</a></code>  </td><td><p class="starttd">GigE Vision compliant cameras </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>PylonCLSer </td><td><code>Pylon::CBaslerCameraLinkCamera</code>  </td><td>Serial Camera Link cameras  </td></tr>
</table>
<h1><a class="anchor" id="grabbingimages"></a>
Grabbing Images</h1>
<h2><a class="anchor" id="Terminology"></a>
Terminology</h2>
<h3><a class="anchor" id="AcquireTransferGrab"></a>
Acquire, Transfer, and Grab Images</h3>
<p>In this document we distinguish between image acquisition, image data transfer, and image grabbing.</p>
<p>We denote the processes inside the camera as image acquisition. When a camera starts image acquisition, the sensor is exposed. When exposure is complete, the image data is read out from the sensor.</p>
<p>The acquired image data is transferred from the camera's memory to the PC using an interface such as IEEE 1394 or Gigabit Ethernet.</p>
<p>The process of writing the image data into the PC's main memory is referred to as "grabbing" an image.</p>
<h3><a class="anchor" id="ImageDataStream"></a>
Image Data Stream and Stream Grabber</h3>
<p>A camera may provide different sources for image data, where each source can deliver a stream of image data. In pylon, so called Stream Grabber objects are responsible for managing the process of grabbing data from a stream, i.e., writing the data into the PC's main memory.</p>
<p>A Stream Grabber only grabs images from a single data stream. To grab data from multiple streams, several Stream Grabbers are needed.</p>
<h2><a class="anchor" id="UsingStreamGrabbers"></a>
Using Stream Grabbers</h2>
<p>The following sections describe the use of Stream Grabber objects. The order of this section reflects the sequence in which a typical grab application will use a Stream Grabber object.</p>
<h3><a class="anchor" id="GettingStreamGrabber"></a>
Getting a Stream Grabber</h3>
<p>Stream Grabber objects are managed by Camera objects. The number of available stream grabbers can be determined with the <a class="el" href="struct_pylon_1_1_i_pylon_device.html#ac273cb75151a2968412ab02e8f22bd76"><code>IPylonDevice::GetNumStreamGrabberChannels()</code> </a> method of the camrea object. The <a class="el" href="struct_pylon_1_1_i_pylon_device.html#af9c92ea3117b601b7ea12d61e50012db"><code>IPylonDevice::GetStreamGrabber()</code> </a> method returns a pointer to the <code><a class="el" href="struct_pylon_1_1_i_stream_grabber.html" title="Low Level API: Interface to an (input) data stream. ">Pylon::IStreamGrabber</a></code> object. Before retrieving a Stream Grabber object, the Camera object must be opened. You should check the value retuned by <a class="el" href="struct_pylon_1_1_i_pylon_device.html#ac273cb75151a2968412ab02e8f22bd76"><code>IPylonDevice::GetNumStreamGrabberChannels()</code> </a> to see which index parameter can be used when calling <a class="el" href="struct_pylon_1_1_i_pylon_device.html#af9c92ea3117b601b7ea12d61e50012db"><code>IPylonDevice::GetStreamGrabber()</code> </a> . The Stream Grabber object itself also must be opened before it is used. Some camera objects i.e Camera Link may not support stream grabbers and will return 0 when calling <a class="el" href="struct_pylon_1_1_i_pylon_device.html#ac273cb75151a2968412ab02e8f22bd76"><code>IPylonDevice::GetNumStreamGrabberChannels()</code> </a> .</p>
<p>Example: </p>
<div class="fragment"><div class="line">Camera.Open();</div>
<div class="line"></div>
<div class="line"><span class="comment">// get the number of stream grabbers available</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numGrabbers = Camera.GetNumStreamGrabberChannels();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (numGrabbers &gt; 0) {</div>
<div class="line">  IStreamGrabber* pGrabber = Camera.GetStreamGrabber(0);</div>
<div class="line">  pGrabber-&gt;Open();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// use the grabber</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">  pGrabber-&gt;Close()</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>Never try to call <code>delete</code> or <code>free</code> on a stream grabber pointer retrieved from a Camera object. The Camera object retains ownership of a Stream Grabber object and manages its lifetime.</dd></dl>
<h3><a class="anchor" id="ConfigureStreamGrabber"></a>
Configuring a Stream Grabber</h3>
<p>Independent of the transport layer used, each stream grabber provides two mandatory parameters: </p>
<ul>
<li>MaxBufferSize - Maximum size in bytes of a buffer used for grabbing images </li>
<li>MaxNumBuffer - Maximum number of buffers used for grabbing images</li>
</ul>
<p>A grab application <b>must</b> set the above two parameters before grabbing starts.</p>
<p>Depending on the transport layer, a Stream Grabber provides further parameters such as streaming related timeouts. All of these parameters are set to default values and image grabbing can be performed without tweaking the defaults.</p>
<p>There are two ways for accessing a Stream Grabber's parameters:</p>
<p>The most comfortable way is to use a concrete class for a Stream Grabber object. Each Camera class provides a <code>typedef</code> for the corresponding Stream Grabber class. A Stream Grabber class takes ownership of a <a class="el" href="struct_pylon_1_1_i_stream_grabber.html"><code>IStreamGrabber</code> </a> pointer returned by the <a class="el" href="struct_pylon_1_1_i_pylon_device.html#af9c92ea3117b601b7ea12d61e50012db"><code>GetStreamGrabber()</code> </a> method. The Stream Grabber class has members to access the Stream Grabber object's parameters.</p>
<p>Example: </p>
<div class="fragment"><div class="line">Camera.Open();</div>
<div class="line"><span class="keywordflow">if</span> (Camera.GetNumStreamGrabberChannels() == 0) {</div>
<div class="line">  <span class="comment">// device doesn&#39;t support stream grabbers</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">IStreamGrabber* pGrabber = Camera.GetStreamGrabber(0);</div>
<div class="line">CBaslerGigECamera::StreamGrabber_t StreamGrabber( pGrabber );</div>
<div class="line"></div>
<div class="line"><span class="comment">// First open the stream grabber</span></div>
<div class="line">StreamGrabber.Open();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set the maximum buffer size according to the amount of data</span></div>
<div class="line"><span class="comment">// the camera will send</span></div>
<div class="line">StreamGrabber.MaxBufferSize = Camera.PayloadSize();</div>
<div class="line"></div>
<div class="line"><span class="comment">// We are going to use 10 buffers</span></div>
<div class="line">StreamGrabber.MaxNumBuffer = 10;</div>
</div><!-- fragment --><p>When using the generic programming approach, i.e., using the <code><a class="el" href="struct_pylon_1_1_i_pylon_device.html" title="Low Level API: Interface for camera objects. ">Pylon::IPylonDevice</a></code> and <code><a class="el" href="struct_pylon_1_1_i_stream_grabber.html" title="Low Level API: Interface to an (input) data stream. ">Pylon::IStreamGrabber</a></code> interfaces instead of Camera and Stream Grabber classes, the <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a97c8096bd4a44c3df836b6c358748f20"><code>IStreamGrabber::GetNodeMap()</code> </a> method must be used to retrieve the GenApi node map holding the stream grabber's parameters.</p>
<p>Stream Grabber node maps are used in the same way as node maps for Camera objects. The use of node maps for Camera objects is described in the <a class="el" href="pylon_programmingguide.html#configuringcameras">Accessing Parameters</a> section.</p>
<h3><a class="anchor" id="PreparingStreamGrabber"></a>
Preparing a Stream Grabber for Grabbing</h3>
<p>Depending on the transport layer used for grabbing images, different system resources are required, for example:</p>
<ul>
<li>DMA resources </li>
<li>Memory for the driver's data structures </li>
<li>Isochronous channel for Firewire cameras </li>
<li>Isochronous bandwidth for Firewire cameras</li>
</ul>
<p>The Stream Grabber's <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a4d8452ec5676d92ea310bc6b5482e559"><code>PrepareGrab()</code> </a> method is used to allocate the needed resources.</p>
<p>In addition to resource allocation, the <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a4d8452ec5676d92ea310bc6b5482e559"><code>PrepareGrab()</code> </a> call causes the camera object to perform a change in state. Typically, the camera parameters controlling the image size (AOI, pixel format, binning, etc.) will be read-only after <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a4d8452ec5676d92ea310bc6b5482e559"><code>PrepareGrab()</code> </a> has been called. These parameters must be set up before calling <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a4d8452ec5676d92ea310bc6b5482e559"><code>PrepareGrab()</code> </a> and must not be changed while image grabbing is active.</p>
<h3><a class="anchor" id="ProvidingMemory"></a>
Providing Memory for Grabbing</h3>
<p>All pylon transport layers can grab image data into memory buffers allocated by a user application. The user allocated memory buffers must be registered at the Stream Grabber object. The registration step is needed for performance reasons, allowing the Stream Grabber to prepare and cache internal data structures used for dealing with user provided memory.</p>
<p>The buffer registration returns handles to the registered buffers, which are used in the steps following the buffer registration.</p>
<p>Example: </p>
<div class="fragment"><div class="line">StreamGrabber.Open();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> bufferSize = (int) Camera.PayloadSize();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> numBuffers = 10;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* ppBuffers[numBuffers];</div>
<div class="line"><a class="code" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a> handles[numBuffers];</div>
<div class="line"></div>
<div class="line">StreamGrabber.MaxBufferSize = bufferSize;</div>
<div class="line">StreamGrabber.MaxNumBuffer = numBuffers;</div>
<div class="line"></div>
<div class="line">StreamGrabber.PrepareGrab();</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; numBuffers; ++i ) {</div>
<div class="line">  ppBuffers[i] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[bufferSize];</div>
<div class="line">  handles[i] = StreamGrabber.RegisterBuffer( ppBuffers[i], bufferSize);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The buffer registration mechanism restricts the ownership of the buffers. Although the content of registered buffers can be changed by the user application, the application must not delete the memory of buffers that are registered. Freeing the memory is not allowed until the buffers are deregistered by using <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a71821eec55efad0345024098d7ebdc30"><code>IStreamGrabber::DeregisterBuffer()</code> </a>.</p>
<h3><a class="anchor" id="FeedingInputQueue"></a>
Feeding the Stream Grabber's Input Queue</h3>
<p>Each Stream Grabber maintains two different buffer queues. The buffers to be filled must be fed into the Grabber's input queue. Grabbed buffers can be retrieved from the Grabber's output queue.</p>
<p>The <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#afad12c655c9064a89c771d3c22a554bb"><code>IStreamGrabber::QueueBuffer()</code> </a> method is used to put a buffer into the grabber's input queue. The <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#afad12c655c9064a89c771d3c22a554bb"><code>QueueBuffer()</code> </a> method accepts two parameters, a buffer handle and an optional, user provided pointer to user provided context information. Together with the buffer, the context pointer is passed back to the user when retrieving the grabbed buffer from the grabber's output queue. A Stream Grabber never changes the memory to which the context pointer is pointing.</p>
<p>Example: </p>
<div class="fragment"><div class="line">MyContext context[numBuffers];</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; numBuffers; ++i ) {</div>
<div class="line">  <span class="comment">// Enqueue image buffers and use the buffer&#39;s index as context</span></div>
<div class="line">  <span class="comment">// information</span></div>
<div class="line">  StreamGrabber.QueueBuffer( handles[i], &amp; context[i] );</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>A stream grabber temporarily takes ownership of an enqueued buffer. Never try to modify or delete a buffer when it has been placed into the stream grabber's input queue.</dd></dl>
<p><b>Queueing buffers into the stream grabber's input queue does not make the camera start acquiring images!</b> After queueing the buffers, the stream grabber is prepared to grab data from the camera into the queued buffers. Image acquisition must be explicitly started.</p>
<h3><a class="anchor" id="StartingAndStop"></a>
Starting and Stopping Image Acquisition</h3>
<p>To start image acquisition, use the Camera object's <a class="el" href="class_basler___gig_e_camera_1_1_c_gig_e_camera___params.html#a4bda898ec39d742626865013b923a014"><code>AcquisitionStart</code> </a> parameter. <a class="el" href="class_basler___gig_e_camera_1_1_c_gig_e_camera___params.html#a4bda898ec39d742626865013b923a014"><code>AcquisitionStart</code> </a> is a command parameter, i.e., calling the <a class="el" href="struct_gen_api_1_1_i_command.html#a4e72b6ccf61c1f92a1334b9e59eb4fc6"><code>Execute()</code> </a> method of the <a class="el" href="class_basler___gig_e_camera_1_1_c_gig_e_camera___params.html#a4bda898ec39d742626865013b923a014"><code>AcquisitionStart</code> </a> parameter sends an acquisition start command to the camera.</p>
<p>A camera device typically provides two acquisition modes: </p>
<ul>
<li>Single Frame mode where the camera acquires one image. </li>
<li>Continuous mode where the camera continuously acquires and transfers images until acquisition is stopped.</li>
</ul>
<p>To be precise, the acquisition start command does not necessarily start immediate acquisition inside of the camera. When either external triggering or software triggering is enabled, the acquisition start command prepares the camera to acquire images. Actual acquisition starts when the camera senses an external trigger signal or receives a software trigger command.</p>
<p>When the camera's continuous acquisition mode is enabled, the <a class="el" href="class_basler___gig_e_camera_1_1_c_gig_e_camera___params.html#a16d7bd1f149335edc3774f11b3a1dd18"><code>AcquisitionStop</code> </a> parameter is used to stop image acquisition.</p>
<p>Normally, a camera starts transferring the image as soon as possible after starting the acquisition, no special command to start the image transfer is needed.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>Basler_GigECameraParams;</div>
<div class="line">Camera.AcquisitionMode.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#a8ff1c67c06562a5dab7821cddc990fc5a1350f94c0c36832867a58dd4f0a7db1d">AcquisitionMode_Continuous</a> );</div>
<div class="line">Camera.AcquisitionStart.Execute();</div>
</div><!-- fragment --><h3><a class="anchor" id="RetrievingGrabbedImages"></a>
Retrieving Grabbed Images</h3>
<p>The transferred image data is written to the buffer(s) in the stream grabber's input queue. When a buffer is filled with grabbed image data, the stream grabber places it into its output queue, from which it can be retrieved by the user application.</p>
<p>There is a wait object associated with the Stream Grabber's output queue. This wait object allows the application to wait until either a grabbed image arrives at the output queue or a timeout expires.</p>
<p>When the wait operation successfully returns, the grabbed buffer can be returned with the Stream Grabber object's <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aebbbda33475dec9e4482e7c8ff66c158"><code>RetrieveResult()</code> </a> method. The <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#aebbbda33475dec9e4482e7c8ff66c158"><code>RetrieveResult()</code> </a> method fills a <code><a class="el" href="class_pylon_1_1_grab_result.html" title="Low Level API: A grab result that combines the used image buffer and status information. ">Pylon::GrabResult</a></code> object. The object contains, among other things, the following information:</p>
<ul>
<li>Status of the grab (succeeded, canceled, failed) </li>
<li>The buffer's handle </li>
<li>The pointer to the buffer </li>
<li>The user provided context pointer </li>
<li>AOI and image format </li>
<li>Error number and error description if the grab has failed</li>
</ul>
<p>When getting a buffer from the grabber's output queue, ownership of the buffer is given over to the application. A buffer retrieved from the output queue will never be overwritten until it is again placed into the grabber's input queue.</p>
<p>Remember, a buffer retrieved from the output queue must be deregistered before its memory can be freed.</p>
<p>We recommended using the buffer handle from the Grab Result object to requeue a buffer into the grabber's input queue.</p>
<p>When the camera does not send data, a buffer remains in the grabber's input queue until the Stream Grabber object's <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a802212e61c56b1b824c4e5612656f056"><code>CancelGrab()</code> </a> method is called. The <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a802212e61c56b1b824c4e5612656f056"><code>CancelGrab()</code> </a> puts all buffers from the input queue to the output queue, including any buffer currently being filled. By checking the status of a Grab Result object, you can determine whether a buffer has been canceled.</p>
<p>The following example shows a typical grab loop: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> numGrabs = 100;</div>
<div class="line">GrabResult Result;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; numGrabs; ++i ) {</div>
<div class="line">  <span class="comment">// Wait for the grabbed image with a timeout of 3 seconds</span></div>
<div class="line">  <span class="keywordflow">if</span> ( StreamGrabber.GetWaitObject().Wait( 3000 )) {</div>
<div class="line">     <span class="comment">// Get an item from the grabber&#39;s output queue</span></div>
<div class="line">     <span class="keywordflow">if</span> ( ! StreamGrabber.RetrieveResult( Result ) ) {</div>
<div class="line">       cerr &lt;&lt; <span class="stringliteral">&quot;Failed to retrieve an item from the output queue&quot;</span> &lt;&lt; endl;</div>
<div class="line">       <span class="keywordflow">break</span>;</div>
<div class="line">     }</div>
<div class="line"></div>
<div class="line">     <span class="keywordflow">if</span> ( Result.Succeeded() ) {</div>
<div class="line">       <span class="comment">// Grabbing was successful. Process the image.</span></div>
<div class="line">       ProcessImage( (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) Result.Buffer() );</div>
<div class="line">     } <span class="keywordflow">else</span> {</div>
<div class="line">       cerr &lt;&lt; <span class="stringliteral">&quot;Grab failed: &quot;</span> &lt;&lt; Result.GetErrorDescription() &lt;&lt; endl;</div>
<div class="line">       <span class="keywordflow">break</span>;</div>
<div class="line">     }</div>
<div class="line">     <span class="comment">// Requeue the buffer</span></div>
<div class="line">     <span class="keywordflow">if</span> ( i + numBuffers &lt; numGrabs )</div>
<div class="line">       StreamGrabber.QueueBuffer( Result.Handle(), Result.Context() );</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    cerr &lt;&lt; <span class="stringliteral">&quot;timeout occurred when waiting for a grabbed image&quot;</span> &lt;&lt; endl;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="FinishGrabbing"></a>
Finish Grabbing</h3>
<p>If the camera is set for continuous acquisition mode, acquisition should first be stopped: </p>
<div class="fragment"><div class="line">Camera.AcquisitionStop.Execute();</div>
</div><!-- fragment --><p>If you are not sure that the grabber's input queue <b>really</b> is empty, the Stream Grabber object's CancelGrab() method should be issued to flush the input queue. The canceled buffers are now available at the grabber's output queue.</p>
<p>An application should retrieve all items from the grabber's output queue before closing a Stream Grabber object.</p>
<p>Before freeing their memory, deregister the buffers.</p>
<p>When all buffers are deregistered, call the Stream Grabber object's <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a8e0ed4cd4c209afccf4a46043de1e88a"><code>FinishGrab()</code> </a> method to release all resources related to grabbing. <a class="el" href="struct_pylon_1_1_i_stream_grabber.html#a8e0ed4cd4c209afccf4a46043de1e88a"><code>FinishGrab()</code> </a> must not be called when there are still buffers in the grabber's input queue!</p>
<p>When grabbing has been finished, a Stream Grabber object should be closed.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="comment">// The camera is in continuous mode, stop the image acquisition</span></div>
<div class="line">Camera.AcquisitionStop.Execute();</div>
<div class="line"><span class="comment">// Flush the input queue</span></div>
<div class="line">StreamGrabber.CancelGrab();</div>
<div class="line"><span class="comment">// Consume all items from the output queue</span></div>
<div class="line"><span class="keywordflow">while</span> ( StreamGrabber.GetWaitObject().Wait(0) ) {</div>
<div class="line">  <span class="keywordflow">if</span> ( ! StreamGrabber.RetrieveResult( Result ) ) {</div>
<div class="line">    cerr &lt;&lt; <span class="stringliteral">&quot;Faile to retrieve item from output queueu&quot;</span> &lt;&lt; endl;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> ( Result.Status() == <a class="code" href="group___pylon___low_level_api.html#gga4afc5255837dea09eb304a583f0c9231a184a33ce883fc87e0ba823d63397f8c8">Canceled</a> ) {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Got canceled buffer&quot;</span> &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; numBuffers; ++i ) {</div>
<div class="line">  StreamGrabber.DeregisterBuffer(handles[i]);</div>
<div class="line">  <span class="keyword">delete</span> [] ppBuffers[i];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">StreamGrabber.FinishGrab();</div>
<div class="line">StreamGrabber.Close();</div>
</div><!-- fragment --><h2><a class="anchor" id="CompleteSample"></a>
Complete Sample program</h2>
<p>Here is the complete sample program for acquiring images from a GigE camera in continuous mode. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_pylon_includes_8h.html">pylon/PylonIncludes.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_basler_gig_e_camera_8h.html">pylon/gige/BaslerGigECamera.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ostream&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>Pylon;</div>
<div class="line"><span class="keyword">using namespace </span>Basler_GigECameraParams;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="class_pylon_1_1_c_basler_gig_e_camera.html">CBaslerGigECamera</a> Camera_t;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> ProcessImage( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pImage, <span class="keywordtype">int</span> imageSizeX, <span class="keywordtype">int</span> imageSizeY )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Do something with the image data</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>MyContext</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Define some application specific context information here</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="class_pylon_1_1_pylon_auto_init_term.html">PylonAutoInitTerm</a> autoInitTerm;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Enumerate GigE cameras</span></div>
<div class="line">    <a class="code" href="class_pylon_1_1_c_tl_factory.html">CTlFactory</a>&amp; TlFactory = <a class="code" href="class_pylon_1_1_c_tl_factory.html#a1d3fbd0bb73b4acd88de7cff893554ab">CTlFactory::GetInstance</a>();</div>
<div class="line">    <a class="code" href="struct_pylon_1_1_i_transport_layer.html">ITransportLayer</a> *pTl = TlFactory.<a class="code" href="class_pylon_1_1_c_tl_factory.html#a6ede1fda37619e7e20e42da42ed74968">CreateTl</a>( Camera_t::DeviceClass() );</div>
<div class="line">    <a class="code" href="class_pylon_1_1_device_info_list.html">DeviceInfoList_t</a> devices;</div>
<div class="line">    <span class="keywordflow">if</span> ( 0 == pTl-&gt;<a class="code" href="struct_pylon_1_1_i_device_factory.html#a7c9485beb3f38fc1c17929a46f6bb7a2">EnumerateDevices</a>( devices ) ) {</div>
<div class="line">      cerr &lt;&lt; <span class="stringliteral">&quot;No camera present!&quot;</span> &lt;&lt; endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create a camera object</span></div>
<div class="line">    Camera_t Camera ( pTl-&gt;<a class="code" href="struct_pylon_1_1_i_device_factory.html#a9891f54248fa6dc0f7cab171044458c4">CreateDevice</a>( devices[ 0 ] ) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Open the camera object</span></div>
<div class="line">    Camera.Open();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Parameterize the camera</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Mono8 pixel format</span></div>
<div class="line">    Camera.PixelFormat.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#a7fe47af68eded4f9424d422dd4d90464a268a5e6a33a60e7b88a5767a147ef285">PixelFormat_Mono8</a> );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Maximized AOI</span></div>
<div class="line">    Camera.OffsetX.SetValue( 0 );</div>
<div class="line">    Camera.OffsetY.SetValue( 0 );</div>
<div class="line">    Camera.Width.SetValue( Camera.Width.GetMax() );</div>
<div class="line">    Camera.Height.SetValue( Camera.Height.GetMax() );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Continuous mode, no external trigger used</span></div>
<div class="line">    Camera.TriggerSelector.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#a4cdbde533baae0acaf4a62a4f99b9055a593dd6dc3407a10be8300efc2c0b3160">TriggerSelector_AcquisitionStart</a> );</div>
<div class="line">    Camera.TriggerMode.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#a4dad9f9f5c53e36bc15f72e4c7b5dda0a5462eb565a9b17ad5e07449c5af6de24">TriggerMode_Off</a> );</div>
<div class="line">    Camera.AcquisitionMode.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#a8ff1c67c06562a5dab7821cddc990fc5a1350f94c0c36832867a58dd4f0a7db1d">AcquisitionMode_Continuous</a> );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Configure exposure time and mode</span></div>
<div class="line">    Camera.ExposureMode.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#acf9d3400e027d196fac23c2726ba61cfa0bc3d188b5a06ca4ed42a26e35b7cf48">ExposureMode_Timed</a> );</div>
<div class="line">    Camera.ExposureTimeRaw.SetValue( 100 );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check whether stream grabbers are avalaible</span></div>
<div class="line">    <span class="keywordflow">if</span> (Camera.GetNumStreamGrabberChannels() == 0) {</div>
<div class="line">      cerr &lt;&lt; <span class="stringliteral">&quot;Camera doesn&#39;t support stream grabbers.&quot;</span> &lt;&lt; endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Get and open a stream grabber</span></div>
<div class="line">      <a class="code" href="struct_pylon_1_1_i_stream_grabber.html">IStreamGrabber</a>* pGrabber = Camera.GetStreamGrabber(0);</div>
<div class="line">      <a class="code" href="class_pylon_1_1_c_pylon_gig_e_camera_t.html#af1ceb55e84a8e3c8834959430d8b1bf6">CBaslerGigECamera::StreamGrabber_t</a> StreamGrabber( Camera.GetStreamGrabber(0) );</div>
<div class="line">      StreamGrabber.<a class="code" href="class_pylon_1_1_c_stream_grabber_proxy_t.html#a8d4f598803a77f38babaea06fa77f059">Open</a>();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Parameterize the stream grabber</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> bufferSize = (int) Camera.PayloadSize();</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> numBuffers = 10;</div>
<div class="line">      StreamGrabber.MaxBufferSize = bufferSize;</div>
<div class="line">      StreamGrabber.MaxNumBuffer = numBuffers;</div>
<div class="line">      StreamGrabber.PrepareGrab();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Allocate and register image buffers, put them into the</span></div>
<div class="line">      <span class="comment">// grabber&#39;s input queue</span></div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* ppBuffers[numBuffers];</div>
<div class="line">      MyContext context[numBuffers];</div>
<div class="line">      <a class="code" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a> handles[numBuffers];</div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; numBuffers; ++i )</div>
<div class="line">      {</div>
<div class="line">        ppBuffers[i] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[bufferSize];</div>
<div class="line">        handles[i] = StreamGrabber.RegisterBuffer( ppBuffers[i], bufferSize);</div>
<div class="line">        StreamGrabber.QueueBuffer( handles[i], &amp;context[i] );</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Start image acquisition</span></div>
<div class="line">      Camera.AcquisitionStart.Execute();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Grab and process 100 images</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> numGrabs = 100;</div>
<div class="line">      <a class="code" href="class_pylon_1_1_grab_result.html">GrabResult</a> Result;</div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; numGrabs; ++i ) {</div>
<div class="line">        <span class="comment">// Wait for the grabbed image with a timeout of 3 seconds</span></div>
<div class="line">        <span class="keywordflow">if</span> ( StreamGrabber.GetWaitObject().Wait( 3000 )) {</div>
<div class="line">          <span class="comment">// Get an item from the grabber&#39;s output queue</span></div>
<div class="line">          <span class="keywordflow">if</span> ( ! StreamGrabber.RetrieveResult( Result ) ) {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">&quot;Failed to retrieve an item from the output queue&quot;</span> &lt;&lt; endl;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">          <span class="keywordflow">if</span> ( Result.<a class="code" href="class_pylon_1_1_grab_result.html#ad4347df15a1e6e219b227e6c87eab363">Succeeded</a>() ) {</div>
<div class="line">            <span class="comment">// Grabbing was successful. Process the image.</span></div>
<div class="line">            ProcessImage( (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) Result.<a class="code" href="class_pylon_1_1_grab_result.html#ac8972b07b439c132a8825bb232c576dd">Buffer</a>(), Result.<a class="code" href="class_pylon_1_1_grab_result.html#ae533cb693a62940df21008ed400c4701">GetSizeX</a>(), Result.<a class="code" href="class_pylon_1_1_grab_result.html#afcdce133eed25abd1d7be1f50b9696ce">GetSizeY</a>() );</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">&quot;Grab failed: &quot;</span> &lt;&lt; Result.<a class="code" href="class_pylon_1_1_grab_result.html#a8f728e84c38204e2528b4b6238696968">GetErrorDescription</a>() &lt;&lt; endl;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">// Requeue the buffer</span></div>
<div class="line">          <span class="keywordflow">if</span> ( i + numBuffers &lt; numGrabs )</div>
<div class="line">            StreamGrabber.QueueBuffer( Result.<a class="code" href="class_pylon_1_1_grab_result.html#a847085d060bfb32e963994f7490ae276">Handle</a>(), Result.<a class="code" href="class_pylon_1_1_grab_result.html#a177554bab016cce1f65a3efa089a6d2f">Context</a>() );</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          cerr &lt;&lt; <span class="stringliteral">&quot;timeout occurred when waiting for a grabbed image&quot;</span> &lt;&lt; endl;</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Finished. Stop grabbing and do clean-up</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// The camera is in continuous mode, stop image acquisition</span></div>
<div class="line">      Camera.AcquisitionStop.Execute();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Flush the input queue, grabbing may have failed</span></div>
<div class="line">      StreamGrabber.CancelGrab();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Consume all items from the output queue</span></div>
<div class="line">      <span class="keywordflow">while</span> ( StreamGrabber.GetWaitObject().Wait(0) ) {</div>
<div class="line">        StreamGrabber.RetrieveResult( Result );</div>
<div class="line">        <span class="keywordflow">if</span> ( Result.<a class="code" href="class_pylon_1_1_grab_result.html#a7e6dcc486dba0cbf73715eb4e9242386">Status</a>() == <a class="code" href="group___pylon___low_level_api.html#gga4afc5255837dea09eb304a583f0c9231a184a33ce883fc87e0ba823d63397f8c8">Canceled</a> )</div>
<div class="line">          cout &lt;&lt; <span class="stringliteral">&quot;Got canceled buffer&quot;</span> &lt;&lt; endl;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Deregister and free buffers</span></div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; numBuffers; ++i ) {</div>
<div class="line">        StreamGrabber.DeregisterBuffer(handles[i]);</div>
<div class="line">        <span class="keyword">delete</span> [] ppBuffers[i];</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Clean up</span></div>
<div class="line">      StreamGrabber.FinishGrab();</div>
<div class="line">      StreamGrabber.Close();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Camera.Close();</div>
<div class="line">    TlFactory.<a class="code" href="class_pylon_1_1_c_tl_factory.html#a0be3fff4a7434adecd20ea6fe9dd23d6">ReleaseTl</a>( pTl );</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>( <a class="code" href="class_gen_i_cam_1_1_generic_exception.html">GenICam::GenericException</a> &amp;e )</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Error handling</span></div>
<div class="line">    cerr &lt;&lt; <span class="stringliteral">&quot;An exception occurred!&quot;</span> &lt;&lt; endl &lt;&lt; e.<a class="code" href="class_gen_i_cam_1_1_generic_exception.html#ac3f2a44c30188d223fac295bd63a9c72">GetDescription</a>() &lt;&lt; endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Quit application</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="grabbingevents"></a>
Handling Camera Events</h1>
<p>Basler GigE Vision and 1394 cameras can send event messages. For example, when a sensor exposure has finished, the camera can send an end-of-exposure event to the PC. The event can be received by the PC before the image data for the finished exposure has been completely transferred. The retrieving and processing of event messages is described in this section.</p>
<h2><a class="anchor" id="EventGrabbers"></a>
Event Grabbers</h2>
<p>The <a class="el" href="low_level_api.html#grabbingimages">Grabbing Images</a> section describes how Stream Grabber objects are used to grab images from a camera. Analogously, <a class="el" href="struct_pylon_1_1_i_event_grabber.html">Event Grabber </a> objects are used to receive event messages from a camera.</p>
<h2><a class="anchor" id="CreatingEventGrabbers"></a>
Creating and Preparing Event Grabbers</h2>
<p>Event Grabber objects are created and returned by <a class="el" href="struct_pylon_1_1_i_pylon_device.html">Camera </a> objects.</p>
<div class="fragment"><div class="line"><span class="comment">// Get the event grabber</span></div>
<div class="line">Camera_t::EventGrabber_t EventGrabber(Camera.GetEventGrabber());</div>
<div class="line"><span class="keywordflow">if</span> ( ! EventGrabber.IsAttached() ) {</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;The camera does not support event grabbing&quot;</span> &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Never try to call <code>free</code> or <code>delete</code> on <a class="el" href="struct_pylon_1_1_i_event_grabber.html">IEventGrabber </a> pointers. The camera object owns Event Grabbers and manages their lifetime.</p>
<p>Event Grabbers use internal memory buffers for receiving event messages. The number of buffers can be parametrized using the Event Grabber's <a class="el" href="class_basler___gig_e_event_params_1_1_c_gig_e_event_params___params.html#aa84dbab15ab9c75c1b1d427f7689a4da">NumBuffer </a> member:</p>
<div class="fragment"><div class="line">EventGrabber.NumBuffer.SetValue(20);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The number of buffers must be parametrized before calling the Event Grabber's <a class="el" href="struct_pylon_1_1_i_event_grabber.html#a915d1fafefea0ff5a7950ac3fdeb0ffc">Open() </a> method!</dd></dl>
<p>A connection to the device and all necessary resources for receiving events are allocated by calling the Event Grabber's <a class="el" href="struct_pylon_1_1_i_event_grabber.html#a915d1fafefea0ff5a7950ac3fdeb0ffc">Open() </a> method:</p>
<div class="fragment"><div class="line">EventGrabber.Open();</div>
</div><!-- fragment --><h2><a class="anchor" id="EnablingEvents"></a>
Enabling Events</h2>
<p>To let the camera send event messages, the sending of event messages must be enabled using the Camera object.</p>
<p>First, the <a class="el" href="class_basler___gig_e_camera_1_1_c_gig_e_camera___params.html#aba75164a4bf15216dbfeb40b8dc99266">EventSelector </a> must be set to the type of event to be enabled. In the following example the selector is set to the end-of-exposure event:</p>
<div class="fragment"><div class="line"><span class="comment">// Select the end-of-exposure event</span></div>
<div class="line">Camera.EventSelector = <a class="code" href="namespace_basler___gig_e_camera.html#ac351d04ad16f30c21cde8b2dc67e1a95aff6d3643784d09a19679ac942fb76484">EventSelector_ExposureEnd</a>;</div>
</div><!-- fragment --><p>When the Event Selector is set, sending events of the desired type can be enabled by using the <a class="el" href="class_basler___gig_e_camera_1_1_c_gig_e_camera___params.html#ac6b833308bea2f31b2494c570be3cdc9">EventNotification </a> parameter:</p>
<div class="fragment"><div class="line"><span class="comment">// Enable sending of events of the selected event type</span></div>
<div class="line">Camera.EventNotification.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#ae5088f3810ce630e1ed34e5b8fe5bafea6d5293db5f74c6ec5129d292eb4a8c2f">EventNotification_GenICamEvent</a> );</div>
</div><!-- fragment --><p>To be sure that you don't miss an event, the Event Grabber should be prepared before events are enabled (see the <a class="el" href="low_level_api.html#CreatingEventGrabbers">Creating and Preparing Event Grabbers</a> section above).</p>
<p>The following code snippet illustrates how to disable the sending end-of-exposure events:</p>
<div class="fragment"><div class="line"><span class="comment">// Select the end-of-exposure event</span></div>
<div class="line">Camera.EventSelector = <a class="code" href="namespace_basler___gig_e_camera.html#ac351d04ad16f30c21cde8b2dc67e1a95aff6d3643784d09a19679ac942fb76484">EventSelector_ExposureEnd</a>;</div>
<div class="line"><span class="comment">// Disable sending of end-of-exposure events</span></div>
<div class="line">Camera.EventNotification.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#ae5088f3810ce630e1ed34e5b8fe5bafea15834fa09f46a7313ffab5bf716d45e1">EventNotification_Off</a> );</div>
</div><!-- fragment --><h2><a class="anchor" id="ReceivingEvents"></a>
Receiving Events</h2>
<p>Receiving events is very similar to grabbing images. The Event Grabber provides a wait object that is signaled when an event message is available. When an event message is available, it can be retrieved by calling the Event Grabber's <a class="el" href="struct_pylon_1_1_i_event_grabber.html#a89797221cd452b65e8d4274bee2940f4">RetrieveEvent() </a> method.</p>
<p>In contrast to grabbing images, memory buffers for receiving events need not be provided by the application. Memory buffers to store event messages are organized by the Event Grabber itself.</p>
<p>In typical applications, waiting for grabbed images and event messages is done in one common loop. This is demonstrated in the following code snippet:</p>
<div class="fragment"><div class="line"><span class="comment">// Add the stream grabber&#39;s and the event grabber&#39;s wait objects to a container</span></div>
<div class="line">WaitObjects waitset;</div>
<div class="line">waitset.Add( EventGrabber.GetWaitObject() );</div>
<div class="line">waitset.Add( StreamGrabber.GetWaitObject() );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> ( doGrabbing ) {</div>
<div class="line">  <span class="comment">// Wait for an image or an event to occur (5 sec timeout)</span></div>
<div class="line">  <span class="keywordtype">int</span> idx;</div>
<div class="line">  <span class="keywordflow">if</span> ( waitset.WaitForAny( 5000, &amp;idx ) ) {</div>
<div class="line">    <span class="comment">// Got event or image</span></div>
<div class="line">    <span class="keywordflow">switch</span> ( idx )</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> 0: <span class="comment">// Event available, get the message</span></div>
<div class="line">      {</div>
<div class="line">        EventResult EvResult;</div>
<div class="line">        <span class="keywordflow">if</span> ( EventGrabber.RetrieveEvent( EvResult ) ) {</div>
<div class="line">          <span class="keywordflow">if</span> ( EvResult.Succeeded() ) {</div>
<div class="line">            <span class="comment">// Successfully got the event message.</span></div>
<div class="line">            <span class="comment">// EvResult.Buffer points to the message</span></div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Error occurred</span></div>
<div class="line">            cerr &lt;&lt; <span class="stringliteral">&quot;Error retrieving event:&quot;</span> &lt;&lt; EvResult.ErrorDescription() &lt;&lt; endl;</div>
<div class="line">          }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// No event available?</span></div>
<div class="line">          <span class="comment">// Should never happen in this sample because the wait object</span></div>
<div class="line">          <span class="comment">// was in signaled state when reaching this point.</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      } <span class="comment">// Case 0</span></div>
<div class="line">    <span class="keywordflow">case</span> 1: <span class="comment">// Image available, process it</span></div>
<div class="line">      {</div>
<div class="line">        GrabResult GrResult;</div>
<div class="line">        <span class="keywordflow">if</span> (StreamGrabber.RetrieveResult( GrResult )) {</div>
<div class="line">          <span class="keywordflow">if</span> (GrResult.Succeeded()) {</div>
<div class="line">            <span class="comment">// Process the image</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// Reuse the buffer for further grabbing</span></div>
<div class="line">            StreamGrabber.QueueBuffer( GrResult.Handle(), GrResult.Context() );</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// handle error</span></div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } <span class="comment">// Case 1</span></div>
<div class="line">    }  <span class="comment">// Switch</span></div>
<div class="line">  } <span class="comment">// if</span></div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// handle timeout</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// While</span></div>
</div><!-- fragment --><h2><a class="anchor" id="DispatchingEvents"></a>
Parsing and Dispatching Events</h2>
<p>The previous section explained how to receive an event message. This section describes how to interpret an event message.</p>
<p>The specific layout of event messages depends on the event type and the camera type. The pylon API uses GenICam support for parsing event messages. This means that the message layout is described in the camera's XML description file.</p>
<p>As described in the <a class="el" href="pylon_advanced_topics.html#GenApiNodeMaps">GenApi Node Maps</a> section, a GenApi node map is created from the XML camera description file. That node map contains node objects representing the elements of the XML file. Since the layout of event messages is described in the camera description file, the information carried by the event messages is exposed as nodes in the node map. The camera object provides members used for accessing the event related nodes in the same way as camera parameter related nodes.</p>
<p>For example, an end-of-exposure event carries the following information: </p>
<ul>
<li>ExposureEndEventFrameID: indicates the number of the image frame that has been exposed </li>
<li>ExposureEndEventTimestamp: indicates the moment when the event was generated </li>
<li>ExposureEndEventStreamChannelIndex: indicates the number of the image data stream used to transfer the exposed frame</li>
</ul>
<p>Example: The camera object's <a class="el" href="class_basler___gig_e_camera_1_1_c_gig_e_camera___params.html#a9bfa538118444d02536cc9d1814ace68">Pylon::CBaslerGigECamera::ExposureEndEventFrameID</a> member is used to access the number of the frame the event is associated with: </p>
<div class="fragment"><div class="line">int64_t frameNr = Camera.ExposureEndEventFrameID.GetValue();</div>
</div><!-- fragment --><p>As described in the <a class="el" href="pylon_programmingguide.html#configuringcameras">Accessing Parameters</a> section, the ExposureEndEventFrameID could also be retrieved by using the camera object's node map directly:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_gen_api_1_1_i_node_map.html">GenApi::INodeMap</a>* pNodeMap = pCamera-&gt;GetNodeMap();</div>
<div class="line"><a class="code" href="group___gen_api___public_utilities.html#gaf688b006c4c1c4c568e85dda02f44280">CIntegerPtr</a> ptrExposureEndFrameId = pNodeMap-&gt;<a class="code" href="struct_gen_api_1_1_i_node_map.html#a493d5d9c380c2bb04c03d8874f133f57">GetNode</a>(<span class="stringliteral">&quot;ExposureEndFrameId&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> ( ! ptrExposureEndFrameId ) {</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;There is no exposure time parameter&quot;</span> &lt;&lt; endl;</div>
<div class="line">  exit( 1 );</div>
<div class="line">}</div>
<div class="line">int64_t frameNr = ptrExposureEndFrameId-&gt;GetValue();</div>
</div><!-- fragment --><p>An <a class="el" href="struct_pylon_1_1_i_event_adapter.html">Event Adapter </a> object is used to update the event related nodes of the camera object's node map. Updating the nodes is done by passing the event message to an Event Adapter.</p>
<p>Event Adapters are created by Camera objects:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_pylon_1_1_i_event_adapter.html">Pylon::IEventAdapter</a> *pEventAdapter = Camera.CreateEventAdapter();</div>
<div class="line"><span class="keywordflow">if</span> ( pEventAdapter == NULL ) {</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create an event adapter&quot;</span> &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To update the event related nodes, call the Event Adapter's <a class="el" href="struct_pylon_1_1_i_event_adapter.html#aae01089735a0d81de2fceb35d6984f03">DeliverMessage() </a> method for each received event message:</p>
<div class="fragment"><div class="line"><span class="comment">// Retrieve the event result</span></div>
<div class="line">EventResult EvResult;</div>
<div class="line"><span class="keywordflow">if</span> ( EventGrabber.RetrieveEvent( EvResult ) ) {</div>
<div class="line">  <span class="keywordflow">if</span> ( EvResult.Succeeded() ) {</div>
<div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;Successfully got an event message!&quot;</span> &lt;&lt; endl;</div>
<div class="line">     <span class="comment">// Let the event adapter update the camera object&#39;s node map</span></div>
<div class="line">     EventAdapter.DeliverMessage( EvResult.Buffer, <span class="keyword">sizeof</span> EvResult.Buffer );</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">     cerr &lt;&lt; <span class="stringliteral">&quot;Error retrieving event:&quot;</span> &lt;&lt; EvResult.ErrorDescription() &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is not possible to determine whether a message contains an end-of-exposure event by passing the event message to the Event Adapter. The next section describes how node callbacks are used to get informed about the occurrence of specific events.</p>
<h2><a class="anchor" id="EventCallbacks"></a>
Event Callbacks</h2>
<p>The previous section described how <a class="el" href="struct_pylon_1_1_i_event_adapter.html">Event Adapters </a> are used to push the content of event messages into a camera object's node map. The <a class="el" href="struct_pylon_1_1_i_event_adapter.html#aae01089735a0d81de2fceb35d6984f03">IEventAdapter::DeliverMessages() </a> method updates all nodes related to events contained in the message passed in.</p>
<p>As described in the <a class="el" href="pylon_advanced_topics.html#GettingInformedAboutParameterChanges">Getting Informed About Parameter Changes</a> section, it is possible to register callback functions that are fired when nodes may have been changed.</p>
<p>These callbacks can be used to determine if an event message contains a certain event type. For example, to get informed about end-of-exposure events, a callback for one of the end-of-exposure event related nodes must be installed. The following code snippet illustrates how to install a callback function for the ExposureEndFrameId node:</p>
<div class="fragment"><div class="line"><span class="comment">// Member function of this class will be registered as callback</span></div>
<div class="line"><span class="keyword">struct </span>CallbackTarget</div>
<div class="line">{</div>
<div class="line">  CallbackTarget( Camera_t&amp; Camera )</div>
<div class="line">    : m_Camera( Camera )</div>
<div class="line">  { }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Will be fired when an end-of-exposure event occurs</span></div>
<div class="line">  <span class="keywordtype">void</span> EndOfExposureCallback( <a class="code" href="struct_gen_api_1_1_i_node.html">GenApi::INode</a>* pNode )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;The message contains an end-of-exposure event.&quot;</span> &lt;&lt; endl;</div>
<div class="line">      cout &lt;&lt; <span class="stringliteral">&quot;Timestamp: &quot;</span> &lt;&lt; m_pCamera-&gt;ExposureEndEventTimestamp.GetValue()</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot;Frame number: &quot;</span> &lt;&lt; m_pCamera-&gt;ExposureEndEventFrameID.GetValue() &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> ( <a class="code" href="class_gen_i_cam_1_1_generic_exception.html">GenICam::GenericException</a>&amp; e )</div>
<div class="line">    {</div>
<div class="line">      cerr &lt;&lt; <span class="stringliteral">&quot;Failed to get event information. Exception occurred:&quot;</span></div>
<div class="line">           &lt;&lt; e.<a class="code" href="class_gen_i_cam_1_1_generic_exception.html#ac3f2a44c30188d223fac295bd63a9c72">GetDescription</a>() &lt;&lt; endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  Camera_t&amp; m_Camera;</div>
<div class="line">} callbackTarget( Camera );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Register the callback for the ExposureEndEventTimestamp node.</span></div>
<div class="line"><a class="code" href="namespace_gen_api.html#aa699284b069f02e89d85a0f7525a8777">GenApi::CallbackHandleType</a> hCb = <a class="code" href="group___gen_api___public_utilities.html#ga9a5c3e2bce3cdc6db812068660832f1f">GenApi::Register</a>(</div>
<div class="line">  pCamera-&gt;ExposureEndEventTimestamp.GetNode(),</div>
<div class="line">  callbackTarget,</div>
<div class="line">  &amp;CallbackTarget::EndOfExposureCallback );</div>
</div><!-- fragment --><p>The registered callback will be fired from the context of the IEventAdapter::DeliverMessage() function. </p>
<dl class="section note"><dt>Note</dt><dd>Since one event message can aggregate multiple events, DeliverMessage will issue multiple calls to a callback function when multiple events of the same type are available.</dd></dl>
<h2><a class="anchor" id="EventCleanUp"></a>
Cleanup</h2>
<p>Before closing and deleting the Camera object, the event related objects must be closed and destroyed as illustrated in the following code snippet:</p>
<div class="fragment"><div class="line"><span class="comment">// Disable sending of end-of-exposure events</span></div>
<div class="line">Camera.EventSelector = <a class="code" href="namespace_basler___gig_e_camera.html#ac351d04ad16f30c21cde8b2dc67e1a95aff6d3643784d09a19679ac942fb76484">EventSelector_ExposureEnd</a>;</div>
<div class="line">Camera.EventNotification.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#ae5088f3810ce630e1ed34e5b8fe5bafea15834fa09f46a7313ffab5bf716d45e1">EventNotification_Off</a> );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Cleanup of event grabber and event adapter</span></div>
<div class="line"><span class="comment">// Deregister the callback first, or else when shutting down the event grabber</span></div>
<div class="line">Camera.ExposureEndEventTimestamp.GetNode()-&gt;DeregisterCallback( hCb );</div>
<div class="line"><span class="comment">// Close the event grabber to tear down the connection</span></div>
<div class="line"><span class="comment">// and free the resources used for receiving events</span></div>
<div class="line">EventGrabber.Close();</div>
<div class="line"><span class="comment">// Delete the event adapter object</span></div>
<div class="line">Camera.DestroyEventAdapter( pEventAdapter );</div>
</div><!-- fragment --><h1><a class="anchor" id="parsingchunks"></a>
Chunk Parser: Accessing Chunk Features</h1>
<p>Basler Cameras can send additional information appended to the image data, such as frame counters, time stamps, and CRC checksums. This section explains how to enable Chunk Features and how to access the added data.</p>
<h2><a class="anchor" id="enablingchunks"></a>
Enabling Chunks</h2>
<p>Before a feature producing a chunk can be activated, the camera's chunk mode must be activated:</p>
<div class="fragment"><div class="line"><span class="comment">// Open the camera</span></div>
<div class="line">Camera.Open();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Enable chunks in general</span></div>
<div class="line"><span class="keywordflow">if</span> ( <a class="code" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9">GenApi::IsWritable</a>( Camera.ChunkModeActive ) ) {</div>
<div class="line">  Camera.ChunkModeActive.SetValue( <span class="keyword">true</span> );</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;The camera does not support chunk features&quot;</span> &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>When the camera is in chunk mode, it transfers data blocks that are partitioned into chunks. The first chunk is always the image data. When chunk features are enabled, the image data chunk is followed by chunks containing the information generated by the chunk features.</p>
<p>Once the chunk mode is activated, chunk features can be enabled:</p>
<div class="fragment"><div class="line">Camera.ChunkSelector.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#adb4045e6559563f047d3dcae52b2c485a01d63670adb21d18b84ebf78351d3312">ChunkSelector_Timestamp</a> );</div>
<div class="line">Camera.ChunkEnable.SetValue( <span class="keyword">true</span> );</div>
</div><!-- fragment --><h2><a class="anchor" id="grabbingChunkImages"></a>
Grabbing Buffers</h2>
<p>Grabbing from an image stream with chunks is very similar to grabbing from an image stream without chunks. Memory buffers must be provided that are large enough to store both the image data and the added chunk data.</p>
<p>The camera's <code>PayloadSize</code> parameter reports the necessary buffersize (in bytes):</p>
<div class="fragment"><div class="line"><span class="comment">// Ask for the buffer size</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> ImageSize = (size_t) ( Camera.PayloadSize.GetValue() );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate buffer(s)</span></div>
<div class="line">uint8_t *pBuffer = <span class="keyword">new</span> uint8_t[ ImageSize ];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Inform the stream grabber about the buffer size</span></div>
<div class="line">StreamGrabber.MaxBufferSize.SetValue( ImageSize );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Tell the stream grabber how many buffers will be used</span></div>
<div class="line"><span class="comment">// ( in this example only 1 )</span></div>
<div class="line">StreamGrabber.MaxNumBuffer.SetValue( 1 );</div>
</div><!-- fragment --><p>Now an image plus added chunks can be grabbed:</p>
<div class="fragment"><div class="line"><span class="comment">// Allocate resources related to grabbing</span></div>
<div class="line">StreamGrabber.PrepareGrab();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Subscribe the buffer</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="namespace_pylon.html#a19e429c33326e1b739f6d451158f35d4">StreamBufferHandle</a> hBuffer =</div>
<div class="line">  StreamGrabber.RegisterBuffer( pBuffer, ImageSize );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Put buffer into the grab queue so it will be filled with data</span></div>
<div class="line">StreamGrabber.QueueBuffer( hBuffer, NULL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Let the camera acquire one image</span></div>
<div class="line">Camera.AcquisitionMode.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#a8ff1c67c06562a5dab7821cddc990fc5aa2b857eac2da933d017950124d9cc17c">AcquisitionMode_SingleFrame</a> );</div>
<div class="line">Camera.AcquisitionStart.Execute();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">GrabResult Result;</div>
<div class="line"><span class="comment">// Wait for the buffer to be filled</span></div>
<div class="line"><span class="keywordflow">if</span> ( StreamGrabber.GetWaitObject().Wait( 3000 ) ) {</div>
<div class="line">  <span class="comment">// Get the grab result from the grabber&#39;s result queue</span></div>
<div class="line">  StreamGrabber.RetrieveResult( Result );</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// Timeout</span></div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Timeout occurred!&quot;</span> &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ( ! Result.Succeeded() ) {</div>
<div class="line">  <span class="comment">// Error Handling</span></div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;No image acquired!&quot;</span> &lt;&lt; endl;</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Error code : 0x&quot;</span> &lt;&lt; hex</div>
<div class="line">    &lt;&lt; Result.<a class="code" href="class_pylon_1_1_grab_result.html#ada1b31543ba86fcc321651e472a99b10">GetErrorCode</a>() &lt;&lt; endl;</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Error description : &quot;</span></div>
<div class="line">    &lt;&lt; Result.GetErrorDescription() &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Check if a buffer containing chunk data has been received</span></div>
<div class="line"><span class="keywordflow">if</span> ( <a class="code" href="group___pylon___instant_camera_api_generic.html#ggaf50b993da3a56a8a843e4d54e15b2329a5424a047d0e7ac6d548ced0dcad05b3e">PayloadType_ChunkData</a> != Result.GetPayloadType () ) {</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Unexpected payload type received&quot;</span> &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="chunkparsing"></a>
Accessing the Chunk Data</h2>
<p>The data block containing the image chunk and the other chunks has a self-descriptive layout. Before accessing the data in the added chunks, the data block must be parsed by a <a class="el" href="struct_pylon_1_1_i_chunk_parser.html">Chunk Parser </a> object.</p>
<p>The Camera object is responsible for creating a Chunk Parser:</p>
<div class="fragment"><div class="line"><span class="comment">// Create ChunkParser</span></div>
<div class="line">IChunkParser &amp;ChunkParser = *Camera.CreateChunkParser();</div>
</div><!-- fragment --><p>Once a <a class="el" href="struct_pylon_1_1_i_chunk_parser.html">Chunk Parser </a> is created, grabbed buffers can be attached to the Chunk Parser. When a buffer is attached to a chunk parser, it is parsed and the chunk data access is provided by members of the Camera object.</p>
<div class="fragment"><div class="line"><span class="comment">// Attach image buffer with chunk data to the parser. The parser extracts</span></div>
<div class="line"><span class="comment">// the included data from the chunk.</span></div>
<div class="line">pChunkParser-&gt;AttachBuffer( Result.Buffer(), Result.GetPayloadSize() );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Access the chunk data.</span></div>
<div class="line"><span class="comment">// Before accessing the chunk data, it should be checked to see</span></div>
<div class="line"><span class="comment">// if the chunk is readable. When it is readable, the buffer</span></div>
<div class="line"><span class="comment">// contains the requested chunk data.</span></div>
<div class="line"><span class="keywordflow">if</span> ( <a class="code" href="group___gen_api___public_interface.html#ga9429c4373073d861a7daa9309b578dd7">IsReadable</a>(Camera.ChunkTimestamp) )</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;TimeStamp : &quot;</span> &lt;&lt; Camera.ChunkTimestamp.GetValue() &lt;&lt; endl;</div>
</div><!-- fragment --><p>To check the result of the CRC Checksum chunk feature, use the Chunk Parser's <a class="el" href="struct_pylon_1_1_i_chunk_parser.html#a774ea6638a134c3fcbecbd7506a5fadc"><code>HasCRC()</code> </a> and <a class="el" href="struct_pylon_1_1_i_chunk_parser.html#afa5fcbd36a9d52cf62c985fb4c76e6b1"><code>CheckCRC()</code> </a> methods. Note that the camera only sends a CRC when the CRC Checksum feature is enabled.</p>
<div class="fragment"><div class="line"><span class="comment">// Enable crc chunks  ( before PrepareGrab()! )</span></div>
<div class="line">Camera.ChunkSelector.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#adb4045e6559563f047d3dcae52b2c485a484fff12106ff9dcb0e921e87509e595">ChunkSelector_PayloadCRC16</a> );</div>
<div class="line">Camera.ChunkEnable.SetValue( <span class="keyword">true</span> );</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Check the CRS sum ( after having the buffer attached to the Chunk Parser)</span></div>
<div class="line"><span class="keywordflow">if</span> ( pChunkParser-&gt;HasCRC() &amp;&amp; !pChunkParser-&gt;CheckCRC() ) {</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Image was damaged!&quot;</span> &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Before reusing a buffer for grabbing, the buffer must be detached from the Chunk Parser.</p>
<div class="fragment"><div class="line"><span class="comment">// After detaching the buffer, the chunk data is no longer accessible!</span></div>
<div class="line">pChunkParser-&gt;DetachBuffer();</div>
</div><!-- fragment --><p>After detaching a buffer, the next grabbed buffer can be attached and the included chunk data can be read.</p>
<p>When you have finished grabbing, the Chunk Parser must be deleted:</p>
<div class="fragment"><div class="line"><span class="comment">// Destroy the chunk parser</span></div>
<div class="line">Camera.DestroyChunkParser( pChunkParser );</div>
</div><!-- fragment --><h1><a class="anchor" id="pnp"></a>
Getting Informed About Device Removal</h1>
<p>Callback functions can be installed that are triggered when a Camera device has been removed. As soon as the Camera object's <a class="el" href="struct_pylon_1_1_i_device.html#a416ff56935bd159fef72dc9318a27d89"><code>Open()</code> </a> method has been called, either a C or C++ class member function can be installed as callbacks.</p>
<p>Installing a C function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RemovalCallbackFunction( IPylonDevice* pDevice )</div>
<div class="line">{</div>
<div class="line">  cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Callback function for removal of device &quot;</span></div>
<div class="line">      &lt;&lt; pDevice-&gt;GetDeviceInfo().GetFullName().c_str() &lt;&lt; <span class="stringliteral">&quot; has been fired&quot;</span> &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Open the camera</span></div>
<div class="line">pCamera-&gt;Open();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Register a &quot;normal&quot; function</span></div>
<div class="line"><a class="code" href="namespace_pylon.html#a521a3e55bdd1d15d57e87fe8419fec3c">DeviceCallbackHandle</a> hCb2 = <a class="code" href="group___pylon___low_level_api.html#ga8c5f584bea00db1c7110e37d26624a07">RegisterRemovalCallback</a>( pCamera, &amp;RemovalCallbackFunction);</div>
</div><!-- fragment --><p>Installing a C++ class member function:</p>
<div class="fragment"><div class="line"><span class="comment">// A class with a member function that can be registered for device removal notifications</span></div>
<div class="line"><span class="keyword">class </span>AClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// The member function to be registered</span></div>
<div class="line">  <span class="keywordtype">void</span> RemovalCallbackMemberFunction( IPylonDevice* pDevice )</div>
<div class="line">  {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Member function callback for removal of device &quot;</span></div>
<div class="line">      &lt;&lt; pDevice-&gt;GetDeviceInfo().GetFullName().c_str() &lt;&lt; <span class="stringliteral">&quot; has been fired&quot;</span> &lt;&lt; endl;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">  AClass a;  <span class="comment">// A member function of this class will be registered as a removal callback function</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Open the camera</span></div>
<div class="line">  pCamera-&gt;Open();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Register a member function</span></div>
<div class="line">  <a class="code" href="namespace_pylon.html#a521a3e55bdd1d15d57e87fe8419fec3c">DeviceCallbackHandle</a> hCb1 = <a class="code" href="group___pylon___low_level_api.html#ga8c5f584bea00db1c7110e37d26624a07">RegisterRemovalCallback</a>( pCamera, a, &amp;AClass::RemovalCallbackMemberFunction);</div>
</div><!-- fragment --><p>All registered callbacks must be deregistered before calling the Camera object's <a class="el" href="struct_pylon_1_1_i_device.html#a27815ab3e22253e4a9d76baca227ef3d"><code>Close()</code> </a> method.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( ! pCamera-&gt;DeregisterRemovalCallback( hCb1 ) )</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Failed to deregister the callback function&quot;</span> &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">pCamera-&gt;Close();</div>
</div><!-- fragment --> </div></div><!-- contents -->
<hr><address><small>
&copy;&nbsp;2006-2014&nbsp;<a href="http://www.baslerweb.com/">Basler</a>   (Tue Jul 22 2014 11:41:22)</small></address>
</body>
</html>
