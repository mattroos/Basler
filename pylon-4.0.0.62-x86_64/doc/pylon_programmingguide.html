<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pylon: Programmer&#39;s Guide and API Reference for pylon for Linux</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-linux.css" rel="stylesheet" type="text/css"/>
<div><img src="Banner_PG.png" /></div>
</head>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Programmer's Guide and API Reference for pylon for Linux</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Programmer's Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="pylon_programmingguide.html#hi_hints">Getting Started</a> </li>
<li><a class="el" href="pylon_programmingguide.html#buildingapplications_brief">Common Settings for Building Applications with pylon</a> </li>
<li><a class="el" href="pylon_programmingguide.html#debugging_brief">Debugging pylon Applications Using GigE Cameras</a> </li>
<li><a class="el" href="pylon_programmingguide.html#initterminate">Initialization/Uninitialization of the pylon Runtime Library</a> </li>
<li><a class="el" href="pylon_programmingguide.html#errorhandling">Error Handling</a> </li>
<li><a class="el" href="pylon_programmingguide.html#enumerating_and_creating_brief">Creating a pylon Device</a> </li>
<li><a class="el" href="pylon_programmingguide.html#hi_instantcameras">The Instant Camera Classes</a> </li>
<li><a class="el" href="pylon_programmingguide.html#configuringcameras">Accessing Parameters</a> </li>
<li><a class="el" href="pylon_programmingguide.html#hi_grabbingimages">Grabbing Images</a> </li>
<li><a class="el" href="pylon_programmingguide.html#hi_advanced_features">Using Advanced Camera Features</a> </li>
<li><a class="el" href="pylon_programmingguide.html#hi_image_handling">Image Handling</a></li>
</ul>
<h1><a class="anchor" id="hi_hints"></a>
Getting Started</h1>
<p>The pylon Programmer's Guide is a quick guide on how to program using the Basler pylon C++ API. It can be used together with the <a class="el" href="sample_code.html">pylon sample code</a> for getting started. Additionally, the <a href="modules.html" class="el">API reference</a> provides documentation about the Basler pylon C++ interface. The documentation of the interfaces is also available in the header files of pylon.</p>
<h1><a class="anchor" id="runningapplications_brief"></a>
Common Settings for Running Applications with pylon</h1>
<p>To run a pylon application on Linux the environment has to be adjusted, so that the dynamic linker finds all dependencies. For your convenience, the <code>$PYLON_ROOT/bin/pylon-setup-env.sh</code> shell script sets up the environment correctly. To setup your environment run </p>
<div class="fragment"><div class="line">source /opt/pylon4/bin/pylon-setup-env.sh /opt/pylon4</div>
</div><!-- fragment --><p> in the current shell.</p>
<p>This will adjust the environment as follows: </p>
<ul>
<li><code>PYLON_ROOT</code> points to the given pylon installation path, e.g. <code>/opt/pylon4</code> </li>
<li><code>GENICAM_ROOT_V2_3</code> points to the GenIcam root: <code>$PYLON_ROOT/genicam</code> </li>
<li><code>LD_LIBRARY_PATH</code> is extended.</li>
</ul>
<h1><a class="anchor" id="buildingapplications_brief"></a>
Common Settings for Building Applications with pylon</h1>
<p>This section shows the most common Linux build settings for building a 32 bit application using pylon and the GNU tool chain. Consult the <a class="el" href="pylon_advanced_topics.html#buildingapplications">Advanced Topics</a> section for more information, e.g. when a different configuration is required.</p>
<p>Add the following include directories in your make file: </p>
<div class="fragment"><div class="line">-I<span class="stringliteral">&quot;$(PYLON_ROOT)/include&quot;</span> -I<span class="stringliteral">&quot;$(PYLON_GENICAM_ROOT)/library/CPP/include&quot;</span></div>
</div><!-- fragment --><p>Add the following library directories in your make file: </p>
<div class="fragment"><div class="line">-L<span class="stringliteral">&quot;$(PYLON_ROOT)/lib&quot;</span> -L<span class="stringliteral">&quot;$(PYLON_GENICAM_ROOT)/library/CPP/lib/Linux32_i86&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="debugging_brief"></a>
Debugging pylon Applications Using GigE Cameras</h1>
<p>When debugging a pylon application using GigE cameras you may encounter heartbeat timeouts. The application must send special network packets to the camera in defined intervals. If the camera doesn't receive these heartbeats it will consider the connection as broken and won't accept any commands from the application. This requires setting the heartbeat timeout of a camera to a higher value when debugging. The <a class="el" href="pylon_advanced_topics.html#debugging">Advanced Topics</a> section shows how to do this.</p>
<h1><a class="anchor" id="initterminate"></a>
Initialization/Uninitialization of the pylon Runtime Library</h1>
<p>The pylon runtime system must be initialized before use. A pylon-based application must call the <code><a class="el" href="namespace_pylon.html#af8226766d27eea5b88d21e56889719ce" title="Initializes the pylon runtime system. ">PylonInitialize()</a></code> method before using any other functions of the pylon runtime system. Before an application exits, it must call the <code><a class="el" href="namespace_pylon.html#abc016fa068af2d088de26dd899a1f544" title="Frees resources allocated by the pylon runtime system. ">PylonTerminate()</a></code> method to free resources allocated by the pylon runtime system.</p>
<p>The <code><a class="el" href="class_pylon_1_1_pylon_auto_init_term.html" title="Helper class to automagically call PylonInitialize and PylonTerminate in constructor and destructor...">Pylon::PylonAutoInitTerm</a></code> convenience class helps to do the above. The constructor of <code>PylonAutoInitTerm</code> calls <code><a class="el" href="namespace_pylon.html#af8226766d27eea5b88d21e56889719ce" title="Initializes the pylon runtime system. ">PylonInitialize()</a></code>, the destructor calls <code><a class="el" href="namespace_pylon.html#abc016fa068af2d088de26dd899a1f544" title="Frees resources allocated by the pylon runtime system. ">PylonTerminate()</a></code>. This ensures that the pylon runtime system is initialized during the lifetime of an object of the <code>PylonAutoInitTerm</code> type.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_pylon_includes_8h.html">pylon/PylonIncludes.h</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>Pylon;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">  <a class="code" href="class_pylon_1_1_pylon_auto_init_term.html">Pylon::PylonAutoInitTerm</a> autoInitTerm;  <span class="comment">// PylonInitialize() will be called now</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Use pylon</span></div>
<div class="line">  <span class="comment">// ..</span></div>
<div class="line"></div>
<div class="line">}  <span class="comment">// autoInitTerm&#39;s destructor calls PylonTerminate() now</span></div>
</div><!-- fragment --><h1><a class="anchor" id="errorhandling"></a>
Error Handling</h1>
<p>In the case of errors, the methods of pylon classes may throw C++ exceptions. The pylon C++ API throws exceptions that are subclasses of <code><a class="el" href="class_gen_i_cam_1_1_generic_exception.html" title="GenICam&#39;s exception class. ">GenICam::GenericException</a></code>. You should guard pylon calls with exception handlers catching <code><a class="el" href="class_gen_i_cam_1_1_generic_exception.html" title="GenICam&#39;s exception class. ">GenICam::GenericException</a></code>. Example: </p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">  camera.Width.SetValue( 640 );</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> ( <a class="code" href="class_gen_i_cam_1_1_generic_exception.html">GenICam::GenericException</a>&amp; e)</div>
<div class="line">{</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Failed to set the AOI width. Reason: &quot;</span></div>
<div class="line">  &lt;&lt; e.<a class="code" href="class_gen_i_cam_1_1_generic_exception.html#ac3f2a44c30188d223fac295bd63a9c72">GetDescription</a>() &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Since <code><a class="el" href="class_gen_i_cam_1_1_generic_exception.html" title="GenICam&#39;s exception class. ">GenICam::GenericException</a></code> inherits from <code>std::exception</code>, an alternative exception handler for exceptions of the <code>std::exception</code> type can be used: </p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">  camera.Width.SetValue( 640 );</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> ( std::exception&amp; e)</div>
<div class="line">{</div>
<div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Failed to set the AOI width. Reason: &quot;</span></div>
<div class="line">    &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="enumerating_and_creating_brief"></a>
Creating a pylon Device</h1>
<p>In pylon, physical camera devices are represented by <a class="el" href="struct_pylon_1_1_i_pylon_device.html">pylon Devices</a>. The following example shows how to create a pylon Device:</p>
<div class="fragment"><div class="line">IPylonDevice* pDevice = CTlFactory::GetInstance().CreateFirstDevice();</div>
</div><!-- fragment --><p>The first found camera device is created, e.g. for a vision system that uses only one camera. The <a class="el" href="pylon_advanced_topics.html#enumerating_and_creating">Advanced Topics</a> section shows how to handle multiple camera devices and how to find specific camera devices.</p>
<dl class="section note"><dt>Note</dt><dd>When a camera is created for the first time the <a class="el" href="pylon_advanced_topics.html#GenApiNodeMaps">GenICam</a> parameter description file of the camera is processed. The result of the processing is stored in a cache on disk. That's why the first creation takes longer then subsequent ones. If the first time creation is done by a program that was started using a debugger then the initial processing can take a couple of minutes. This is because Windows provides a special debug heap when a program is started by a debugger and because processing the parameter description file causes a lot of heap allocations that take longer when the debug heap is used. The camera can be opened once with the pylon Viewer tool or the program can be started without debugging to avoid long waiting.</dd></dl>
<h1><a class="anchor" id="hi_instantcameras"></a>
The Instant Camera Classes</h1>
<p>Instant Camera classes make it possible to grab images with a few lines of code reducing the programming effort to a minimum. An Instant Camera class uses a pylon Device internally. The pylon Device needs to be created and attached to the Instant Camera object for operation.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="comment">// Create an instant camera object with the camera device found first.</span></div>
<div class="line">CInstantCamera camera( CTlFactory::GetInstance().CreateFirstDevice());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Print the model name of the camera.</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Using device &quot;</span> &lt;&lt; camera.GetDeviceInfo().GetModelName() &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Start the grabbing of c_countOfImagesToGrab images.</span></div>
<div class="line">        <span class="comment">// The camera device is parameterized with a default configuration which</span></div>
<div class="line">        <span class="comment">// sets up free-running continuous acquisition.</span></div>
<div class="line">        camera.StartGrabbing( c_countOfImagesToGrab);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// This smart pointer will receive the grab result data.</span></div>
<div class="line">        CGrabResultPtr ptrGrabResult;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Camera.StopGrabbing() is called automatically by the RetrieveResult() method</span></div>
<div class="line">        <span class="comment">// when c_countOfImagesToGrab images have been retrieved.</span></div>
<div class="line">        <span class="keywordflow">while</span> ( camera.IsGrabbing())</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Wait for an image and then retrieve it. A timeout of 5000 ms is used.</span></div>
<div class="line">            camera.RetrieveResult( 5000, ptrGrabResult, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Image grabbed successfully?</span></div>
<div class="line">            <span class="keywordflow">if</span> (ptrGrabResult-&gt;GrabSucceeded())</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Access the image data.</span></div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;SizeX: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetWidth() &lt;&lt; endl;</div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;SizeY: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetHeight() &lt;&lt; endl;</div>
<div class="line">                <span class="keyword">const</span> uint8_t *pImageBuffer = (uint8_t *) ptrGrabResult-&gt;GetBuffer();</div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;Gray value of first pixel: &quot;</span> &lt;&lt; (uint32_t) pImageBuffer[0] &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef PYLON_WIN_BUILD</span></div>
<div class="line"><span class="preprocessor"></span>                <span class="comment">// Display the grabbed image.</span></div>
<div class="line">                Pylon::DisplayImage(1, ptrGrabResult);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorCode() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorDescription() &lt;&lt; endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
</div><!-- fragment --><p>The above code snippet can be found in the code sample <a class="el" href="sample_code.html#sample_Grab">Grab</a>.</p>
<h2><a class="anchor" id="hi_mainfeatures_instantcameras"></a>
The Main Features of an Instant Camera Class</h2>
<p>The Instant Camera classes establish convenient access to a camera device while being highly customizable. The following list shows the main features of an Instant Camera class:</p>
<ul>
<li>It serves as single access point for accessing camera functionality. </li>
<li>It can be used "out of the shelf" without setting any parameters. The camera uses a default configuration for the device. The default configuration can be overridden. </li>
<li>It handles pylon Device lifetime. </li>
<li>It opens and closes a pylon Device automatically. </li>
<li>It handles the creation, reuse and destruction of buffers. </li>
<li>It provides a grab loop thread if required. </li>
<li>It detects camera device removal. </li>
<li>It supports advanced camera features like chunk mode and event reporting (camera events). </li>
<li>Is extensible using derivation. </li>
<li>Is extensible by registering additional event handler objects.</li>
</ul>
<h2><a class="anchor" id="hi_typesof_instantcameras"></a>
Types of Instant Camera Classes</h2>
<p>Before starting to program you need to decide what Instant Camera class to use. The following table shows the available Instant Camera classes:</p>
<table  border="1" class="table" frame="void" cellspacing="6" cellpadding="7">
<tr>
<th>Name of Class </th><th>Usable for Device Type </th><th>Device Specific  </th></tr>
<tr>
<td><code><a class="el" href="class_pylon_1_1_c_instant_camera.html" title="Provides convenient access to a camera device. ">Pylon::CInstantCamera</a></code>  </td><td>All cameras </td><td>No  </td></tr>
<tr>
<td><code><a class="el" href="class_pylon_1_1_c_basler_gig_e_instant_camera.html" title="Extends the CInstantCamera by GigE specific parameter interface classes and GigE specific methods...">Pylon::CBaslerGigEInstantCamera</a></code>  </td><td>GigE Vision compliant cameras </td><td>Yes  </td></tr>
<tr>
<td><code><a class="el" href="class_pylon_1_1_c_basler_usb_instant_camera.html" title="Extends the CInstantCamera by USB specific parameter interface classes. ">Pylon::CBaslerUsbInstantCamera</a></code>  </td><td>USB3 Vision compliant cameras </td><td>Yes  </td></tr>
</table>
<p>The generic <a class="el" href="class_pylon_1_1_c_instant_camera.html"><code>CInstantCamera</code> </a> camera class allows to operate camera devices of all types. The class should be used when programming for multiple device types, e.g. GigE and IIDC 1394 devices, and if the type of device used is not known at compile time.</p>
<p>The Device Specific Instant Camera classes are specializations of <a class="el" href="class_pylon_1_1_c_instant_camera.html"><code>CInstantCamera</code> </a> extending it by a parameter class. The parameter class provides a member for each camera parameter. One of these Device Specific Instant Camera classes should be used when programming for only one device type, e.g. for GigE devices.</p>
<h2><a class="anchor" id="hi_eventhandler_instantcameras"></a>
Instant Camera Event Handler Basics</h2>
<p>The Instant Camera classes allow to register event handler objects for customizing the behavior of the camera object, for processing grab results, and for handling camera events. The following list shows the available event handler types.</p>
<ul>
<li>Configuration event handler - can be used for customizing the behavior of the camera; must be derived from the <code><a class="el" href="class_pylon_1_1_c_configuration_event_handler.html" title="The configuration event handler base class. ">Pylon::CConfigurationEventHandler</a></code> base class. </li>
<li>Image event handler - can be used for processing the grab results; must be derived from the <code><a class="el" href="class_pylon_1_1_c_image_event_handler.html" title="The image event handler base class. ">Pylon::CImageEventHandler</a></code> base class. </li>
<li>Camera event handler - must be used for processing camera events; must be derived from the <code><a class="el" href="class_pylon_1_1_c_camera_event_handler.html" title="The camera event handler base class. ">Pylon::CCameraEventHandler</a></code> base class.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For Device Specific Instant Camera classes separate event handler base classes are available which use the Device Specific Instant Camera class and the device specific grab result smart pointer class.</dd></dl>
<p>A custom event handler class can override one or more virtual methods of the base class. For instance whenever <code><a class="el" href="class_pylon_1_1_c_configuration_event_handler.html#ae1824c64953412d5fecb1456a6396113" title="This method is called after the attached Pylon Device has been opened. ">Pylon::CConfigurationEventHandler::OnOpened</a></code> is called by an Instant Camera object it is the right time to set up camera parameters. The following code snippet shows an example of a configuration event handler setting the image area of interest (Image AOI) and the pixel format.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CPixelFormatAndAoiConfiguration : <span class="keyword">public</span> <a class="code" href="class_pylon_1_1_c_configuration_event_handler.html">Pylon::CConfigurationEventHandler</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_pylon_1_1_c_configuration_event_handler.html#ae1824c64953412d5fecb1456a6396113">OnOpened</a>( <a class="code" href="class_pylon_1_1_c_instant_camera.html">Pylon::CInstantCamera</a>&amp; camera)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Allow all the names in the namespace GenApi to be used without qualification.</span></div>
<div class="line">            <span class="keyword">using namespace </span>GenApi;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get the camera control object.</span></div>
<div class="line">            <a class="code" href="struct_gen_api_1_1_i_node_map.html">INodeMap</a> &amp;control = camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#a3227195969200a52200364bf31e9c586">GetNodeMap</a>();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get the parameters for setting the image area of interest (Image AOI).</span></div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="class_gen_api_1_1_c_pointer.html">CIntegerPtr</a> width = control.GetNode(<span class="stringliteral">&quot;Width&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="class_gen_api_1_1_c_pointer.html">CIntegerPtr</a> height = control.GetNode(<span class="stringliteral">&quot;Height&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="class_gen_api_1_1_c_pointer.html">CIntegerPtr</a> offsetX = control.GetNode(<span class="stringliteral">&quot;OffsetX&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="class_gen_api_1_1_c_pointer.html">CIntegerPtr</a> offsetY = control.GetNode(<span class="stringliteral">&quot;OffsetY&quot;</span>);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Maximize the Image AOI.</span></div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9">IsWritable</a>(offsetX))</div>
<div class="line">            {</div>
<div class="line">                offsetX-&gt;SetValue(offsetX-&gt;GetMin());</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9">IsWritable</a>(offsetY))</div>
<div class="line">            {</div>
<div class="line">                offsetY-&gt;SetValue(offsetY-&gt;GetMin());</div>
<div class="line">            }</div>
<div class="line">            width-&gt;SetValue(width-&gt;GetMax());</div>
<div class="line">            height-&gt;SetValue(height-&gt;GetMax());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Set the pixel data format.</span></div>
<div class="line">            <a class="code" href="group___gen_api___public_utilities.html#gaac6d21b97dd92a1b2a364f1623f54ccb">CEnumerationPtr</a>(control.GetNode(<span class="stringliteral">&quot;PixelFormat&quot;</span>))-&gt;FromString(<span class="stringliteral">&quot;Mono8&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span> (<a class="code" href="class_gen_i_cam_1_1_generic_exception.html">GenICam::GenericException</a>&amp; e)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">throw</span> <a class="code" href="group___base___public_impl.html#ga16e6d812cf9af13e0f4106c77689e46b">RUNTIME_EXCEPTION</a>( <span class="stringliteral">&quot;Could not apply configuration. GenICam::GenericException caught in OnOpened method msg=%hs&quot;</span>, e.<a class="code" href="class_gen_i_cam_1_1_generic_exception.html#ad6cdbc527256a4a2b932065964d017ff">what</a>());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>One or more event handler objects can be registered at the Instant Camera object. The following code snippet shows an example of how the above event handler is registered and appended to the configuration event handler list.</p>
<div class="fragment"><div class="line"><span class="comment">// Register an additional configuration handler to set the image format and adjust the AOI.</span></div>
<div class="line"><span class="comment">// By setting the registration mode to RegistrationMode_Append, the configuration handler is added instead of replacing</span></div>
<div class="line"><span class="comment">// the already registered configuration handler.</span></div>
<div class="line">camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#aefc4e8480ceec5fe3991f059e1c4d8d4">RegisterConfiguration</a>( <span class="keyword">new</span> CPixelFormatAndAoiConfiguration, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga6ad39f74e5f882a64461ad02c70567eda06f0a0d28b2552f5b7240e2344d37302">RegistrationMode_Append</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>);</div>
</div><!-- fragment --><p>For more information about registering and deregistering event handlers consult the interface documentation of the <a class="el" href="pylon_programmingguide.html#hi_typesof_instantcameras">Instant Camera class</a> used and the codes of the following samples: <a class="el" href="sample_code.html#sample_ParametrizeCamera_Configurations">ParametrizeCamera_Configurations</a>, <a class="el" href="sample_code.html#sample_Grab_UsingGrabLoopThread">Grab_UsingGrabLoopThread</a>, and <a class="el" href="sample_code.html#sample_Grab_CameraEvents">Grab_CameraEvents</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to use the Instant Camera classes without using event handler objects.</dd></dl>
<h2><a class="anchor" id="hi_eventhandler_configurations"></a>
Configurations</h2>
<p>Configuration event handler classes are also just called "configurations" because they encapsulate certain camera configurations. The pylon C++ API comes with the following configuration classes:</p>
<ul>
<li><code><a class="el" href="class_pylon_1_1_c_acquire_single_frame_configuration.html" title="An instant camera configuration for single frame acquisition, Use together with CInstantCamera::GrabO...">Pylon::CAcquireSingleFrameConfiguration</a></code> - for single frame acquisition mode. </li>
<li><code><a class="el" href="class_pylon_1_1_c_acquire_continuous_configuration.html" title="Changes the configuration of the camera to free-running continuous acquisition. ">Pylon::CAcquireContinuousConfiguration</a></code> - for continuous frame acquistion mode. </li>
<li><code><a class="el" href="class_pylon_1_1_c_software_trigger_configuration.html" title="Changes the configuration of the camera so that it is triggered by software trigger. ">Pylon::CSoftwareTriggerConfiguration</a></code> - for software trigger mode.</li>
</ul>
<p>These classes are provided as header files. This makes it possible to see what parameters of the camera are changed. The code can be copied and modified for creating own configuration classes. <code><a class="el" href="class_pylon_1_1_c_software_trigger_configuration.html" title="Changes the configuration of the camera so that it is triggered by software trigger. ">Pylon::CSoftwareTriggerConfiguration</a></code> for instance can be used as basis for creating a hardware trigger configuration with few modifications. <code><a class="el" href="class_pylon_1_1_c_acquire_continuous_configuration.html" title="Changes the configuration of the camera to free-running continuous acquisition. ">Pylon::CAcquireContinuousConfiguration</a></code> is already registered when creating an Instant Camera class, providing a default setup that will work for most cameras.</p>
<p>The following example shows how to apply the software trigger configuration:</p>
<div class="fragment"><div class="line"><span class="comment">// Register the standard configuration event handler for enabling software triggering.</span></div>
<div class="line"><span class="comment">// The software trigger configuration handler replaces the default configuration</span></div>
<div class="line"><span class="comment">// as all currently registered configuration handlers are removed by setting the registration mode to RegistrationMode_ReplaceAll.</span></div>
<div class="line">camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#aefc4e8480ceec5fe3991f059e1c4d8d4">RegisterConfiguration</a>( <span class="keyword">new</span> CSoftwareTriggerConfiguration, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga6ad39f74e5f882a64461ad02c70567eda622d43aab16f129b874526cd63d1a74b">RegistrationMode_ReplaceAll</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>);</div>
</div><!-- fragment --><p>The code sample <a class="el" href="sample_code.html#sample_ParametrizeCamera_Configurations">ParametrizeCamera_Configurations</a> provides more examples showing the use of configurations.</p>
<h2><a class="anchor" id="hi_instant_camera_array"></a>
Handling Multiple Cameras Using Instant Camera Arrays</h2>
<p>The Instant Camera Array classes help managing multiple cameras in a system. An Instant Camera Array represents an array of instant camera objects. It provides almost the same interface as an Instant Camera for grabbing. The main purpose of the CInstantCameraArray is to simplify waiting for images and camera events of multiple cameras in one thread. This is done by providing a single RetrieveResult method for all cameras in the array. The following classes are available:</p>
<ul>
<li><code><a class="el" href="class_pylon_1_1_c_instant_camera_array.html" title="Supports grabbing with multiple camera devices. ">Pylon::CInstantCameraArray</a></code> - used if the type of camera device used is not known at compile time. </li>
<li><code><a class="el" href="class_pylon_1_1_c_basler_gig_e_instant_camera_array.html" title="GigE specific instant camera array. ">Pylon::CBaslerGigEInstantCameraArray</a></code> - used together with GigE camera devices. </li>
<li><code><a class="el" href="class_pylon_1_1_c_basler_usb_instant_camera_array.html" title="USB specific instant camera array. ">Pylon::CBaslerUsbInstantCameraArray</a></code> - used together with USB camera devices.</li>
</ul>
<p>The <a class="el" href="sample_code.html#sample_Grab_MultipleCameras">Grab_MultipleCameras</a> code sample illustrates the use of the <a class="el" href="class_pylon_1_1_c_instant_camera_array.html"><code>CInstantCameraArray</code> </a> class.</p>
<h1><a class="anchor" id="configuringcameras"></a>
Accessing Parameters</h1>
<p>For camera configuration and for accessing other parameters, the pylon API uses the technologies defined by the GenICam standard. The GenICam specification (<a href="http://www.GenICam.org">http://www.GenICam.org</a>) defines a format for camera parameter description files. These files describe the configuration interface of GenICam compliant cameras. The description files are written in XML (eXtensible Markup Language) and describe camera registers, their interdependencies, and all other information needed to access high-level features such as Gain, Exposure Time, or Image Format by means of low level register read and write operations.</p>
<p>The elements of a camera description file are represented as software objects called Nodes. For example, a node can represent a single camera register, a camera parameter such as Gain, a set of available parameter values, etc. Each node implements the <code><a class="el" href="struct_gen_api_1_1_i_node.html" title="Interface common to all nodes. ">GenApi::INode</a></code> interface.</p>
<p>The nodes have different types. For example, there are nodes representing integer values and other nodes representing strings. For each type of parameter, there is an interface in GenApi. These interfaces are described in the <a class="el" href="pylon_programmingguide.html#ParameterTypes">Parameter Types</a> section. The <a class="el" href="pylon_programmingguide.html#AccessModes">Access Modes for Parameters</a> section introduces the concept of a parameter access mode. An access mode property is used to determine whether a parameter is available, readable, or writable.</p>
<p>The complete set of nodes is stored in a data structure called node map.</p>
<dl class="section note"><dt>Note</dt><dd>Not only camera devices are parameterized using GenICam node maps. Also, most pylon objects provide node maps to provide access to their parameters. Therefore, a common way for accessing parameters is established.</dd></dl>
<h2><a class="anchor" id="OpeningAndClosing"></a>
Opening and Closing a Camera</h2>
<p>Before reading or writing parameters of a camera, the drivers involved must be initialized and a connection to the physical camera device must be established. This is done by calling the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d55354035ee749bc587b4d923a22c5f"><code>Open()</code> </a> method. The camera can be closed using the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a56fd8d061c6762f8f60e14a0e1345738"><code>Close()</code> </a> method.</p>
<h2><a class="anchor" id="native_parameter_access"></a>
Native Parameter Access</h2>
<p>pylon provides programming interface classes that are created from parameter description files using the code generators provided by <a class="el" href="namespace_gen_i_cam.html" title="Contains definitions of GenICam types and exceptions. ">GenICam</a>'s <a class="el" href="namespace_gen_api.html" title="Contains definitions of the types of GenICam GenApi modules. ">GenApi</a> module. Such programming interface classes are exported by the Device Specific Instant Camera classes. Thereby, a member is provided for each available parameter. This is the easiest way to access parameters.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Maximize the image area of interest (Image AOI).</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9">IsWritable</a>(camera.OffsetX))</div>
<div class="line">{</div>
<div class="line">    camera.OffsetX.SetValue(camera.OffsetX.GetMin());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9">IsWritable</a>(camera.OffsetY))</div>
<div class="line">{</div>
<div class="line">    camera.OffsetY.SetValue(camera.OffsetY.GetMin());</div>
<div class="line">}</div>
<div class="line">camera.Width.SetValue(camera.Width.GetMax());</div>
<div class="line">camera.Height.SetValue(camera.Height.GetMax());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set the pixel data format.</span></div>
<div class="line">camera.PixelFormat.SetValue(<a class="code" href="namespace_basler___gig_e_camera.html#a7fe47af68eded4f9424d422dd4d90464a268a5e6a33a60e7b88a5767a147ef285">PixelFormat_Mono8</a>);</div>
</div><!-- fragment --><p>The <a class="el" href="sample_code.html#sample_ParametrizeCamera_NativeParameterAccess">ParametrizeCamera_NativeParameterAccess</a> code sample shows how to access parameters via generated parameter classes.</p>
<h2><a class="anchor" id="generic_parameter_access"></a>
Generic Parameter Access</h2>
<p>The complete set of nodes is stored in a data structure called node map. At runtime, a node map is instantiated from an XML description. The parameters or nodes must be accessed using a node map object when the type of device used is not known at compile time. This applies, for example, when it is possible that multiple types of camera devices are used by a machine vision application, for example GigE and IIDC 1394 devices.</p>
<p>Example (setting the same parameters as in the above example):</p>
<div class="fragment"><div class="line"><span class="comment">// Allow all the names in the namespace GenApi to be used without qualification.</span></div>
<div class="line"><span class="keyword">using namespace </span>GenApi;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the camera control object.</span></div>
<div class="line"><a class="code" href="struct_gen_api_1_1_i_node_map.html">INodeMap</a> &amp;control = camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#a3227195969200a52200364bf31e9c586">GetNodeMap</a>();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the parameters for setting the image area of interest (Image AOI).</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="class_gen_api_1_1_c_pointer.html">CIntegerPtr</a> width = control.GetNode(<span class="stringliteral">&quot;Width&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="class_gen_api_1_1_c_pointer.html">CIntegerPtr</a> height = control.GetNode(<span class="stringliteral">&quot;Height&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="class_gen_api_1_1_c_pointer.html">CIntegerPtr</a> offsetX = control.GetNode(<span class="stringliteral">&quot;OffsetX&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="class_gen_api_1_1_c_pointer.html">CIntegerPtr</a> offsetY = control.GetNode(<span class="stringliteral">&quot;OffsetY&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Maximize the Image AOI.</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9">IsWritable</a>(offsetX))</div>
<div class="line">{</div>
<div class="line">    offsetX-&gt;SetValue(offsetX-&gt;GetMin());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9">IsWritable</a>(offsetY))</div>
<div class="line">{</div>
<div class="line">    offsetY-&gt;SetValue(offsetY-&gt;GetMin());</div>
<div class="line">}</div>
<div class="line">width-&gt;SetValue(width-&gt;GetMax());</div>
<div class="line">height-&gt;SetValue(height-&gt;GetMax());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set the pixel data format.</span></div>
<div class="line"><a class="code" href="group___gen_api___public_utilities.html#gaac6d21b97dd92a1b2a364f1623f54ccb">CEnumerationPtr</a>(control.GetNode(<span class="stringliteral">&quot;PixelFormat&quot;</span>))-&gt;FromString(<span class="stringliteral">&quot;Mono8&quot;</span>);</div>
</div><!-- fragment --><p>The <a class="el" href="sample_code.html#sample_ParametrizeCamera_GenericParameterAccess">ParametrizeCamera_GenericParameterAccess</a> code sample shows how to use the generic parameter access.</p>
<h2><a class="anchor" id="where_to_find_parameters"></a>
Where to Find Information About Camera Parameters</h2>
<p>The following sources can be used to get information about camera parameters:</p>
<ul>
<li>The camera User's Manual </li>
<li>The interface documentation of the <a class="el" href="pylon_programmingguide.html#hi_typesof_instantcameras">Device Specific Instant Camera</a> classes </li>
<li>The pylon Viewer </li>
<li>The <a class="el" href="index.html#parameter_reference">Parameter Reference</a> </li>
<li>The pylon samples</li>
</ul>
<h2><a class="anchor" id="ParameterTypes"></a>
Parameter Types</h2>
<h3><a class="anchor" id="IntegerParameters"></a>
Integer Parameters</h3>
<p>The <code><a class="el" href="struct_gen_api_1_1_i_integer.html" title="Interface for integer properties. ">GenApi::IInteger</a></code> interface is used to access integer parameters. An integer parameter represents a feature that can be set by an integer number, such as a camera's image width or height in pixels. The current value of an integer parameter is augmented by a minimum and a maximum value, defining a range of allowed values for the parameter, and by an increment that acts as a 'step width' for changes to the parameter's value. The set of all allowed values for an integer parameter can hence be expressed as x&#160;:=&#160;{minimum}&#160;+&#160;N&#160;*&#160;{increment}, with N&#160;=&#160;0,1,2&#160;..., x&#160;&lt;=&#160;{maximum}. The current value, minimum, maximum, and increment can all be accessed as 64 bit values. The following example prints all valid values for the Width parameter:</p>
<div class="fragment"><div class="line">camera.Width = camera.Width.GetMin();</div>
<div class="line">int64_t w = camera.Width.GetMin();</div>
<div class="line"><span class="keywordflow">while</span> ( w &lt;= camera.Width.GetMax() )</div>
<div class="line">{</div>
<div class="line">  cout &lt;&lt; w;</div>
<div class="line">  w += camera.Width.GetInc();</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are two equivalent possibilities for setting a value using the <code><a class="el" href="struct_gen_api_1_1_i_integer.html" title="Interface for integer properties. ">GenApi::IInteger</a></code> interface: </p>
<ul>
<li>Using the assignment operator, e.g.: <div class="fragment"><div class="line">camera.Width = 500; </div>
</div><!-- fragment --> </li>
<li>Using the <code>SetValue()</code> method, e.g.: <div class="fragment"><div class="line">camera.Width.SetValue( 500 ); </div>
</div><!-- fragment --></li>
</ul>
<p>There are also two equivalent ways to get a parameter's current value: </p>
<ul>
<li>Using the function call operator, e.g.: <div class="fragment"><div class="line">t = camera.Width(); </div>
</div><!-- fragment --> </li>
<li>Using the GetValue() method, e.g.: <div class="fragment"><div class="line">t = camera.Width.GetValue(); </div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="FloatingPointParameters"></a>
Floating Point Parameters</h3>
<p>Floating point parameters are represented by <code><a class="el" href="struct_gen_api_1_1_i_float.html" title="Interface for float properties. ">GenApi::IFloat</a></code> objects. A float parameter represents a feature that can be set by a floating-point value, such as a camera's exposure time expressed in seconds. The floating point parameter is similar to the integer parameter with two exceptions: all values are of the 'double' type (double precision floating point numbers as defined by the IEEE 754 standard) and there is no increment value. Hence, a float parameter is allowed to take any value from the interval {minimum} &lt;= x &lt;={maximum}.</p>
<h3><a class="anchor" id="BooleanParameters"></a>
Boolean Parameters</h3>
<p>A boolean parameter represents a binary-valued feature, which, can be enabled or disabled. It is represented by the <code><a class="el" href="struct_gen_api_1_1_i_boolean.html" title="Interface for Boolean properties. ">GenApi::IBoolean</a></code> interface. An example for a boolean parameter would be a 'switch' to enable or disable a particular feature, such as a camera's external trigger input. Set and get operations are similar to the ones used by the <code><a class="el" href="struct_gen_api_1_1_i_integer.html" title="Interface for integer properties. ">GenApi::IInteger</a></code> interface.</p>
<h3><a class="anchor" id="EnumerationParameters"></a>
Enumeration Parameters</h3>
<p>The <code><a class="el" href="struct_gen_api_1_1_i_enumeration.html" title="Interface for enumeration properties. ">GenApi::IEnumeration</a></code> interface is used to represent camera parameters that can take any value from a predefined set. Parameters such as Pixel Format or Test Image Type may serve as examples.</p>
<p>Example: </p>
<div class="fragment"><div class="line">camera.PixelFormat.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#a7fe47af68eded4f9424d422dd4d90464a64a9197959938d8c9d10d163dd9c528c">PixelFormat_Mono16</a> );</div>
</div><!-- fragment --><h3><a class="anchor" id="CommandParameters"></a>
Command Parameters</h3>
<p>Command parameters (<code><a class="el" href="struct_gen_api_1_1_i_command.html">GenApi::ICommand</a></code>) are used for parameters that trigger an action or an operation inside of the camera, e.g. issuing a software trigger. The action is issued by calling the <code><a class="el" href="struct_gen_api_1_1_i_command.html#a4e72b6ccf61c1f92a1334b9e59eb4fc6" title="Execute the command. ">GenApi::ICommand::Execute()</a></code> method. The <code><a class="el" href="struct_gen_api_1_1_i_command.html#aefb06ed9fb0a40c7736e04e1201c1440" title="Query whether the command is executed. ">GenApi::ICommand::IsDone()</a></code> method can be used to determine whether a running operation has finished.</p>
<h3><a class="anchor" id="StringPrameters"></a>
String Parameters</h3>
<p>The <code><a class="el" href="struct_gen_api_1_1_i_string.html" title="Interface for string properties. ">GenApi::IString</a></code> interface provides access to string parameters. The <code><a class="el" href="class_gen_i_cam_1_1gcstring.html" title="A string class which is a clone of std::string. ">GenICam::gcstring</a></code> class is used to represent strings. The <code>gcstring</code> class is similar to the STL <code>std::string</code> class.</p>
<h2><a class="anchor" id="AccessModes"></a>
Access Modes for Parameters</h2>
<p>Each parameter has an access mode that describes whether a feature is implemented, available, readable, and writable. For a given camera, a feature may not be implemented at all. For example, a monochrome camera will not include a white balance feature. Depending on the camera's state, a feature may temporarily not be available. For example, a parameter related to external triggering may not be available when the camera is in free run mode. Available features can be read-only, write-only, or readable and writable.</p>
<p>The current state of a parameter can be queried by calling the parameter's <code>GetAccessMode()</code> method, which returns a <code><a class="el" href="group___gen_api___public_utilities.html#ga0900b33e900e2021e1941455c38207c7">GenApi::EAccessMode</a></code> enumeration value described in the following table:</p>
<table  border="1" class="table" frame="void" cellspacing="6" cellpadding="7">
<tr>
<th>EAccessMode</th><th>Implemented</th><th>Available</th><th>Readable</th><th>Writable </th></tr>
<tr>
<td>NI</td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>NA</td><td>Yes</td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>WO</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes </td></tr>
<tr>
<td>RO</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No </td></tr>
<tr>
<td>RW</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes </td></tr>
</table>
<p>A parameter's access mode can change at runtime. For example, the <code>AOI</code> <code>width</code> and <code>AOI</code> <code>height</code> will be read-only when the camera is acquiring images. So checking a parameter's access mode before using it is recommended. Therefore, the <code><a class="el" href="namespace_gen_api.html" title="Contains definitions of the types of GenICam GenApi modules. ">GenApi</a></code> namespace contains the following helper functions taking either an <code>EAccessMode</code> value, a pointer, or a reference to a parameter: </p>
<ul>
<li><code><a class="el" href="group___gen_api___public_interface.html#ga4048066d0b1880eef906684cd22c1c66" title="Tests if implemented. ">GenApi::IsImplemented</a></code> </li>
<li><code><a class="el" href="group___gen_api___public_interface.html#gaf50a08b3955f5d590b690fb25849b602" title="Tests if available. ">GenApi::IsAvailable</a></code> </li>
<li><code><a class="el" href="group___gen_api___public_interface.html#ga9429c4373073d861a7daa9309b578dd7" title="Tests if readable. ">GenApi::IsReadable</a></code> </li>
<li><code><a class="el" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9" title="Tests if writable. ">GenApi::IsWritable</a></code> </li>
</ul>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_basler_gig_e_instant_camera_8h.html">pylon/gige/BaslerGigEInstantCamera.h</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>Basler_GigECameraParams;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// If the AOI width is writable, set the AOI width</span></div>
<div class="line">  <span class="keywordflow">if</span> ( <a class="code" href="group___gen_api___public_interface.html#ga26ed84e6fb3d3d0136c6cace6ddc0cf9">GenApi::IsWritable</a> ( camera.Width ) )</div>
<div class="line">    camera.Width = 640;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// If the pixel format is supported, set the camera to Mono16 pixel format</span></div>
<div class="line">  <span class="keywordflow">if</span> ( <a class="code" href="group___gen_api___public_interface.html#gaf50a08b3955f5d590b690fb25849b602">GenApi::IsAvailable</a>( camera.PixelFormat.GetEntry(<a class="code" href="namespace_basler___gig_e_camera.html#a7fe47af68eded4f9424d422dd4d90464a64a9197959938d8c9d10d163dd9c528c">PixelFormat_Mono16</a>)) )</div>
<div class="line">    camera.PixelFormat.SetValue( <a class="code" href="namespace_basler___gig_e_camera.html#a7fe47af68eded4f9424d422dd4d90464a64a9197959938d8c9d10d163dd9c528c">PixelFormat_Mono16</a> );</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h1><a class="anchor" id="hi_grabbingimages"></a>
Grabbing Images</h1>
<p>This section shows how to grab images using the Instant Camera class. Before grabbing images the camera parameters must be set up using one or more of the following approaches:</p>
<ul>
<li>Registered <a class="el" href="pylon_programmingguide.html#hi_eventhandler_configurations">configuration objects</a> configure the camera. </li>
<li>The camera is set up using code in the program flow after <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5d55354035ee749bc587b4d923a22c5f"><code>Open()</code> </a> is called. </li>
<li>The camera is preconfigured, e.g. using the pylon Viewer. The settings are stored in a user set in the camera and become active when the camera powers up, provided the user set was selected as the "startup set". </li>
<li>The parameters are loaded from disk. The <a class="el" href="pylon_advanced_topics.html#loadsavecamerafeatures">Advanced Topics</a> section shows how to do this.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Using the latter three approaches may require to remove the default configuration after the Instant Camera object has been created. The following example shows how to do this. The configuration must be removed before calling the Open() method.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Create a camera object</span></div>
<div class="line">CInstantCamera camera;</div>
<div class="line"><span class="comment">// Remove the default configuration</span></div>
<div class="line">camera.<a class="code" href="class_pylon_1_1_c_instant_camera.html#aefc4e8480ceec5fe3991f059e1c4d8d4">RegisterConfiguration</a>( (CConfigurationEventHandler*) NULL, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga6ad39f74e5f882a64461ad02c70567eda622d43aab16f129b874526cd63d1a74b">RegistrationMode_ReplaceAll</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5ab2a4bc04535c971546bf9ad9511e80dc">Cleanup_None</a>);</div>
</div><!-- fragment --><h2><a class="anchor" id="AcquireTransferGrabHi"></a>
Acquire, Transfer, and Grab Images</h2>
<p>In this document we distinguish between image acquisition, image data transfer, and image grabbing.</p>
<p>We denote the processes inside the camera as image acquisition. When a camera starts image acquisition, the sensor is exposed. When exposure is complete, the image data is read out from the sensor.</p>
<p>The acquired image data is transferred from the camera's memory to the PC using an interface such as IEEE 1394 or Gigabit Ethernet.</p>
<p>The process of writing the image data into the PC's main memory is referred to as "grabbing" an image.</p>
<h2><a class="anchor" id="hi_grab_result"></a>
The Grab Result</h2>
<p>The data of a grabbed image is held by a <a class="el" href="class_pylon_1_1_c_grab_result_data.html"><code>Grab</code> <code>Result</code> <code>Data</code> </a> object. The Grab Result Data object cannot be directly accessed. The Grab Result Data object cannot be directly accessed. It is always held by a grab result smart pointer, e.g. the basic grab result smart pointer <a class="el" href="class_pylon_1_1_c_grab_result_ptr.html"><code>CGrabResultPtr</code> </a>. The combination of smart pointer and Grab Result Data object is also referred to as grab result. The smart pointer controls the reuse and the lifetime of the Grab Result Data object and the associated image buffer. When all smart pointers referencing a Grab Result Data object go out of scope, the grab result's image buffer is reused for grabbing. Due to the smart pointer concept, a Grab Result Data object and the associated image buffer can live longer than the camera object used for grabbing the image data. Each Device Specific Instant Camera class has a device specific Grab Result Data object and a device specific grab result smart pointer. A device specific grab result smart pointer can be converted to or from the basic grab result smart pointer CGrabResultPtr by copying or assigning.</p>
<dl class="section note"><dt>Note</dt><dd>The grabbing will stop with a buffer underrun when the grab results are never released, e.g. when put into a container.</dd></dl>
<p>The grab result smart pointer classes provide a cast operator that allows passing a grab result smart pointer directly to functions or methods that take a <code>const</code> <code><a class="el" href="struct_pylon_1_1_i_image.html" title="Usable to access image properties and image buffer. ">Pylon::IImage</a>&amp;</code> as parameter, e.g. image saving functions.</p>
<dl class="section attention"><dt>Attention</dt><dd>The returned reference to <code>IImage</code> is only valid as long the grab result smart pointer it came from is not destroyed.</dd></dl>
<h2><a class="anchor" id="buffer_handling"></a>
Buffer Handling</h2>
<p>New buffers are automatically allocated for each grab session starting with <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a>. The buffer of a grabbed image is held by the Grab Result Data object. While the grabbing is in progress a buffer is reused when the Grab Result Data object is released by the grab result smart pointer. If the Grab Result Data object is released when the grabbing has stopped then the buffer is freed.</p>
<p>The number of used image data buffers can be set using the <a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params.html#a91fb9dcf46847583658bc1468361c9ec"><code>MaxNumBuffer</code> </a> parameter. The default amount of buffers used for grabbing is 10. The buffer size required for grabbing is automatically determined.</p>
<p>The number of allocated buffers is automatically reduced when grabbing a defined number of images smaller than the value of <code>MaxNumBuffer</code>, e.g. 5.</p>
<h2><a class="anchor" id="grab_engine"></a>
The Grab Engine</h2>
<p>The Instant Camera grab engine consists of an empty buffer queue, an output queue, and a grab thread. The grab engine uses a Low Level API stream grabber to grab images. The empty buffer queue and the output queue can hold the number of buffers defined by the <a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params.html#a91fb9dcf46847583658bc1468361c9ec">MaxNumBuffer </a> parameter. <a class="el" href="class_basler___instant_camera_params_1_1_c_instant_camera_params___params.html#a3e40d0ed01c327446ae70fb7a4f35a13">MaxNumQueuedBuffer </a> buffers are passed to the Low Level API stream grabber at any time. All queues work in FIFO mode (First-In-First-Out). The grab engine thread ensures that the stream grabber does not run out of buffers as long as buffers are available in the empty buffer queue.</p>
<h2><a class="anchor" id="grab_strategy_one_by_one_pg"></a>
The Default Grab Strategy One By One</h2>
<p>The Instant Camera supports different grab strategies. The default strategy is One By One. When the grab strategy One By One is used images are processed in the order of their acquisition.</p>
<div class="image">
<img src="pylon_buffer_flow_one_by_one.png" alt="pylon_buffer_flow_one_by_one.png"/>
<div class="caption">
The Buffer Flow Using Grab Strategy One By One.</div></div>
<ul>
<li>The Instant Camera grab engine unqueues buffers from the Empty Buffer Queue and queues the empty buffers at the Low Level API stream grabber (1). </li>
<li>The camera device is triggered (2). An image is acquired by the camera device, it is transfered to the PC and then grabbed into an empty buffer. </li>
<li>The Instant Camera grab engine thread is notified that a filled buffer is available. The filled buffer is retrieved by the grab engine thread (3) and is put into the Output Queue. </li>
<li>The application thread waiting inside the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8">RetrieveResult() </a> method is notified, it stops waiting for a grab result, and it retrieves the filled buffer (4) as part of a grab result data object. </li>
<li>The grab result data object is held by a grab result smart pointer. After the application has processed the image data the filled buffer is returned to the Empty Buffer Queue (5). This is done by the grab result smart pointer destructor or when the grab result data object is explicitly released. Returned buffers are used again for grabbing.</li>
</ul>
<p>More information about grab strategies can be found in the <a class="el" href="pylon_advanced_topics.html#grab_strategies">advanced topics section</a>.</p>
<h2><a class="anchor" id="hi_grab_loop"></a>
Grabbing Images in a Loop</h2>
<p>The following example shows a simple grab loop:</p>
<div class="fragment"><div class="line"><span class="comment">// Create an instant camera object with the camera device found first.</span></div>
<div class="line">CInstantCamera camera( CTlFactory::GetInstance().CreateFirstDevice());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Print the model name of the camera.</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Using device &quot;</span> &lt;&lt; camera.GetDeviceInfo().GetModelName() &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Start the grabbing of c_countOfImagesToGrab images.</span></div>
<div class="line">        <span class="comment">// The camera device is parameterized with a default configuration which</span></div>
<div class="line">        <span class="comment">// sets up free-running continuous acquisition.</span></div>
<div class="line">        camera.StartGrabbing( c_countOfImagesToGrab);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// This smart pointer will receive the grab result data.</span></div>
<div class="line">        CGrabResultPtr ptrGrabResult;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Camera.StopGrabbing() is called automatically by the RetrieveResult() method</span></div>
<div class="line">        <span class="comment">// when c_countOfImagesToGrab images have been retrieved.</span></div>
<div class="line">        <span class="keywordflow">while</span> ( camera.IsGrabbing())</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Wait for an image and then retrieve it. A timeout of 5000 ms is used.</span></div>
<div class="line">            camera.RetrieveResult( 5000, ptrGrabResult, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Image grabbed successfully?</span></div>
<div class="line">            <span class="keywordflow">if</span> (ptrGrabResult-&gt;GrabSucceeded())</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Access the image data.</span></div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;SizeX: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetWidth() &lt;&lt; endl;</div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;SizeY: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetHeight() &lt;&lt; endl;</div>
<div class="line">                <span class="keyword">const</span> uint8_t *pImageBuffer = (uint8_t *) ptrGrabResult-&gt;GetBuffer();</div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;Gray value of first pixel: &quot;</span> &lt;&lt; (uint32_t) pImageBuffer[0] &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef PYLON_WIN_BUILD</span></div>
<div class="line"><span class="preprocessor"></span>                <span class="comment">// Display the grabbed image.</span></div>
<div class="line">                Pylon::DisplayImage(1, ptrGrabResult);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorCode() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorDescription() &lt;&lt; endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
</div><!-- fragment --><p>The camera object is created. The grabbing is started by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a>. Since the camera is not open yet, it is automatically opened by the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a> method. The default configuration event handler is called and it applies the default configuration. Images are grabbed continuously by the Instant Camera object and the grab results are placed into the Instant Camera's output queue in the order they are aqcuired by the camera (Grab Strategy One By One). The <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><code>RetrieveResult()</code> </a> method is used to wait for a grab result and for retrieving it from the output queue. Some of the grab result data is printed to the screen after it is retrieved. <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><code>StopGrabbing()</code> </a> is called automatically by the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><code>RetrieveResult()</code> </a> method when <code>c_countOfImagesToGrab</code> images have been retrieved. The while statement condition is used to check if the grabbing has been stopped.</p>
<p>It is possible to start grabbing for an unlimited number of images by omitting the maximum number of images to grab in the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a> call and call <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><code>StopGrabbing()</code> </a> from inside the grab loop to finish grabbing.</p>
<p>The above code snippet can be found in the <a class="el" href="sample_code.html#sample_Grab">Grab</a> code sample.</p>
<h2><a class="anchor" id="hi_grab_grabloop_thread"></a>
Grabbing Images Using the Grab Loop Thread Provided by the Instant Camera</h2>
<p>The Instant Camera class can optionally provide a grab loop thread. The thread runs a grab loop calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><code>RetrieveResult()</code> </a> repeatedly. When using the provided grab loop thread an image event handler is required to process the grab results.</p>
<p>The following image event handler is used:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CImageEventPrinter : <span class="keyword">public</span> CImageEventHandler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnImageGrabbed( CInstantCamera&amp; camera, <span class="keyword">const</span> CGrabResultPtr&amp; ptrGrabResult)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;OnImageGrabbed event for device &quot;</span> &lt;&lt; camera.GetDeviceInfo().GetModelName() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Image grabbed successfully?</span></div>
<div class="line">        <span class="keywordflow">if</span> (ptrGrabResult-&gt;GrabSucceeded())</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;SizeX: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetWidth() &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;SizeY: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetHeight() &lt;&lt; std::endl;</div>
<div class="line">            <span class="keyword">const</span> uint8_t *pImageBuffer = (uint8_t *) ptrGrabResult-&gt;GetBuffer();</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Gray value of first pixel: &quot;</span> &lt;&lt; (uint32_t) pImageBuffer[0] &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorCode() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ptrGrabResult-&gt;GetErrorDescription() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The following example shows how to grab using the grab loop thread provided by the Instant Camera object:</p>
<div class="fragment"><div class="line"><span class="comment">// The image event printer serves as sample image processing.</span></div>
<div class="line"><span class="comment">// When using the grab loop thread provided by the Instant Camera object, an image event handler processing the grab</span></div>
<div class="line"><span class="comment">// results must be created and registered.</span></div>
<div class="line">camera.RegisterImageEventHandler( <span class="keyword">new</span> CImageEventPrinter, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga6ad39f74e5f882a64461ad02c70567eda06f0a0d28b2552f5b7240e2344d37302">RegistrationMode_Append</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggae495d43181dadd7d44dc47ae1542fed5a33cc17aa219c33ea966e987b906cd364">Cleanup_Delete</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Start the grabbing using the grab loop thread, by setting the grabLoopType parameter</span></div>
<div class="line"><span class="comment">// to GrabLoop_ProvidedByInstantCamera. The grab results are delivered to the image event handlers.</span></div>
<div class="line"><span class="comment">// The GrabStrategy_OneByOne default grab strategy is used.</span></div>
<div class="line">camera.StartGrabbing( <a class="code" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a3a3229ee04054114d6929a1ee325be9a">GrabLoop_ProvidedByInstantCamera</a>);</div>
<div class="line"></div>
<div class="line">cerr &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;Enter \&quot;t\&quot; to trigger the camera or \&quot;e\&quot; to exit and press enter? (t/e)&quot;</span> &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Wait for user input to trigger the camera or exit the program.</span></div>
<div class="line"><span class="comment">// The grabbing is stopped, the device is closed and destroyed automatically when the camera object goes out of scope.</span></div>
<div class="line"><span class="keywordtype">char</span> key;</div>
<div class="line"><span class="keywordflow">do</span></div>
<div class="line">{</div>
<div class="line">    cin.get(key);</div>
<div class="line">    <span class="keywordflow">if</span> ( (key == <span class="charliteral">&#39;t&#39;</span> || key == <span class="charliteral">&#39;T&#39;</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Execute the software trigger. Wait up to 100 ms for the camera to be ready for trigger.</span></div>
<div class="line">        <span class="keywordflow">if</span> ( camera.WaitForFrameTriggerReady( 100, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga038e4dd8fbd49dd4e7ec17cc605d1344af73671a5f5093f8159a973c0ef016a78">TimeoutHandling_ThrowException</a>))</div>
<div class="line">        {</div>
<div class="line">            camera.ExecuteSoftwareTrigger();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">while</span> ( (key != <span class="charliteral">&#39;e&#39;</span>) &amp;&amp; (key != <span class="charliteral">&#39;E&#39;</span>));</div>
</div><!-- fragment --><p>First, the image event handler is registered. It prints a message on the screen for every grabbed image. It serves as image processing in this example. The grabbing is started using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a> for an unlimited number of images and uses the grab loop thread provided by the Instant Camera object by setting the second parameter to GrabLoop_ProvidedByInstantCamera. The main thread can now be used to query the user for input to either trigger an image or to exit the input loop. The grabbing is not explicitly stopped in this example and could be stopped by calling <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><code>StopGrabbing()</code> </a>. The above code snippet can be found in the <a class="el" href="sample_code.html#sample_Grab_UsingGrabLoopThread">Grab_UsingGrabLoopThread</a> code sample.</p>
<h2><a class="anchor" id="hi_grab_one"></a>
Grabbing a Single Image</h2>
<p>For convenience, the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a17b74eca17e24b3ee7c7517fc223f6e3"><code>GrabOne()</code> </a> method can be used to grab a single image. The following code shows a simplified version of what is done:</p>
<div class="fragment"><div class="line"><span class="comment">//grab one image</span></div>
<div class="line">StartGrabbing( 1, <a class="code" href="group___pylon___instant_camera_api_generic.html#gga56a922b1bd37848234153b9e12f7fecba62ef2e619a5079431c23af8061665751">GrabStrategy_OneByOne</a>, <a class="code" href="group___pylon___instant_camera_api_generic.html#ggaf582b0a1fa8604d4e18857bd525291e6a1006c968199ded056843b9c42854b206">GrabLoop_ProvidedByUser</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">//grab is stopped automatically due to maxImages = 1</span></div>
<div class="line"><span class="keywordflow">return</span> RetrieveResult( timeoutMs, grabResult, timeoutHandling) &amp;&amp; grabResult-&gt;GrabSucceeded();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a17b74eca17e24b3ee7c7517fc223f6e3"><code>GrabOne()</code> </a> is more efficient if the pylon Device is already open, otherwise the pylon Device is opened and closed automatically for each call.</dd>
<dd>
Grabbing single images using Software Trigger (<a class="el" href="class_pylon_1_1_c_software_trigger_configuration.html"><code>CSoftwareTriggerConfiguration</code> </a>) is recommended if you want to maximize the frame rate. This is because the overhead per grabbed image is reduced compared to Single Frame Acquisition. The grabbing can be started using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a386b84c29f9ee7ec3646fbfbf70236ed"><code>StartGrabbing()</code> </a>. Images are grabbed using the <a class="el" href="class_pylon_1_1_c_instant_camera.html#a7506b5b38079ba4583a088a620187b29"><code>WaitForFrameTriggerReady()</code> </a>,<a class="el" href="class_pylon_1_1_c_instant_camera.html#ae5a4e166d9198dd4706a1c72c0bc2bc6"><code>ExecuteSoftwareTrigger()</code> </a> and <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3af3b05b85ea0aeb68eb5fb1b6dba0c8"><code>RetrieveResult()</code> </a> methods instead of using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a17b74eca17e24b3ee7c7517fc223f6e3"><code>GrabOne()</code> </a>. The grabbing can be stopped using <a class="el" href="class_pylon_1_1_c_instant_camera.html#a5ef34cbfa61d4f0c2c1739bea5e5ee4f"><code>StopGrabbing()</code> </a> when done.</dd></dl>
<h1><a class="anchor" id="hi_advanced_features"></a>
Using Advanced Camera Features</h1>
<h2><a class="anchor" id="hi_grabbingevents"></a>
Handling Camera Events</h2>
<p>Many cameras can send event messages. For example, when a sensor exposure has finished, the camera can send an end-of-exposure event to the PC. Events can be received by registering an image event handler at an Instant Camera class. See the <a class="el" href="pylon_advanced_topics.html#hi_grabbingevents_ref">Advanced Topics</a> section for more information.</p>
<h2><a class="anchor" id="hi_parsingchunks"></a>
Accessing Chunk Features</h2>
<p>Basler Cameras are able to send additional information as so-called data chunks appended to the image data, such as frame counters, time stamps, or CRC checksums. Data chunks are automatically parsed by the Instant Camera class if activated. See the <a class="el" href="pylon_advanced_topics.html#hi_parsingchunks_ref">Advanced Topics</a> section for more information.</p>
<h2><a class="anchor" id="hi_pnp"></a>
Getting Informed About Camera Device Removal</h2>
<p>To get informed about camera device removal the method <a class="el" href="class_pylon_1_1_c_instant_camera.html#a3bc410c61618d7565455751991ce2791"><code>IsCameraDeviceRemoved()</code> </a> can be queried or a <a class="el" href="pylon_programmingguide.html#hi_eventhandler_configurations">configuration event handler</a> can be registered. The virtual method <a class="el" href="class_pylon_1_1_c_configuration_event_handler.html#afe121efea7306bb5f3d0b8a958d82677"><code>OnCameraDeviceRemoved()</code> </a> is called if a camera device is removed. See the <a class="el" href="pylon_advanced_topics.html#hi_pnp_ref">Advanced Topics</a> section for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>OnCameraDeviceRemoved</code> call is made from a separate thread.</dd></dl>
<h2><a class="anchor" id="hi_broadcast_multicast"></a>
Multicast/Broadcast: Grab Images of One Camera on Multiple PCs</h2>
<p>Basler GigE cameras can be configured to send the image data stream to multiple destinations. Either IP multicasts or IP broadcasts can be used. For more information consult the <a class="el" href="pylon_advanced_topics.html#MulticastGrabbing">advanced topics section</a>.</p>
<h1><a class="anchor" id="hi_image_handling"></a>
Image Handling</h1>
<p>Besides the Instant Camera classes used for grabbing images pylon offers additional <a class="el" href="group___pylon___image_handling_support.html">Image Handling Support</a> support for handling grabbed images. There are an image class, an image format converter, and the loading and saving of images.</p>
<h2><a class="anchor" id="hi_pylon_image"></a>
The Pylon Image Class</h2>
<p>When working with image data the handling of buffer size and lifetime often involves a lot of coding. The <code><a class="el" href="class_pylon_1_1_c_pylon_image.html" title="Describes an image. ">Pylon::CPylonImage</a></code> class simplifies this. It also allows to attach a buffer of a grab result preventing its reuse as long as required. Additionally, user buffers or buffers provided by third party software packages can be connected. Besides that, the pylon Image class helps when working with image planes or AOIs. The <a class="el" href="sample_code.html#sample_Utility_Image">Utility_Image</a> code sample shows the use of the pylon Image class.</p>
<h2><a class="anchor" id="hi_image_format_converter"></a>
The Image Format Converter</h2>
<p>The <code><a class="el" href="class_pylon_1_1_c_image_format_converter.html" title="Creates new images by converting a source image to another format. ">Pylon::CImageFormatConverter</a></code> creates new images by converting a source image to a different format. Once the format converter is configured it can convert almost all image formats supported by Basler camera devices. The <a class="el" href="sample_code.html#sample_Utility_ImageFormatConverter">Utility_ImageFormatConverter</a> code sample shows the use of the Image Format Converter class.</p>
<h2><a class="anchor" id="hi_image_load_save"></a>
Loading and Saving Images</h2>
<p>The <code><a class="el" href="class_pylon_1_1_c_image_persistence.html" title="Contains static functions supporting loading and saving of images. ">Pylon::CImagePersistence</a></code> class supports loading and saving images to disk. The pylon Image classes use this interface internally and provide methods for loading and saving. The <a class="el" href="sample_code.html#sample_Utility_ImageLoadAndSave">Utility_ImageLoadAndSave</a> code sample shows how to load and save images. </p>
</div></div><!-- contents -->
<hr><address><small>
&copy;&nbsp;2006-2014&nbsp;<a href="http://www.baslerweb.com/">Basler</a>   (Tue Jul 22 2014 11:41:22)</small></address>
</body>
</html>
